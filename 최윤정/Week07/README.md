# 📗 토비의 스프링 3.1 Vol.1 스프링의 이해와 원리
## 📝 6장 AOP
## 6.5 스프링 AOP
지금까지 해왔던 작업 목표 : 
- 비즈니스 로직에 반복 등장해야만 했던 트랜잭션 코드 깔끔+효과적 분리하는 것. 

- 트랜잭션 코드는 투명한 부가기능 형태로 제공돼야 함.
	> "투명하다" : 부가기능 적용 후에도 기존 설계와 코드엔 영향 X

투명한 부가기능 적용하는 과정에서 발견됐던 거의 대부분의 문제는 제거함.

그런데, 아직 한 가지 해결할 과제가 남아있다.

### 프록시 팩토리 빈 방식의 접근 방법의 한계 2가지
1. 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제 => ✅ 스프링 ProxyFactoryBean의 어드바이스 통해 해결
2. 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보 추가해야 함 => **🤔 이런 류의 중복은 제거할 방법이 없나?** => **✅ 빈 후처리기를 이용한 자동 프록시 생성하면 됨**

## 빈 후처리기를 이용한 자동 프록시 생성기
🌱 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외엔 대부분 확장할 수 있도록 확장 포인트를 제공해줌.
> 그중 가장 관심 가질 만한 확장 포인트 :  BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기

<br>

### ✅ 빈 후처리기
- 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해줌. 

<br>

### ✅ 스프링이 제공하는 빈 후처리기 중 하나인 `DefaultAdvisorAutoProxyCreator`
- 어드바이저를 이용한 자동 프록시 생성기

- 빈 후처리기를 스프링에 적용하는 방법 : 빈 후처리기 자체를 빈으로 등록
- 스프링이 설정 참고해 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 게 가능
	- 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장 + 프록시를 빈으로 대신 등록 가능 = **자동 프록시 생성 빈 후처리기**

<br>

### 📝 빈 후처리기를 이용한 자동 프록시 생성 방법
1. `DefaultAdvisorAutoProxyCreator` 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보냄

2. `DefaultAdvisorAutoProxyCreator`는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인
3. 프록시 적용 대상이면, 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해줌
4. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려줌
5. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용함

<br>

### 👀 확장된 포인트컷
#### 포인트컷 두가지 기능
1. 프록시를 적용할 클래스인지 확인

2. 어드바이스를 적용할 메소드인지 확인
```java
public interface Pointcut{
	ClassFilter getClassFilter();
	MethodMatcher getMethodMatcher(); 
}
```

만약 포인트컷 선정 기능 모두 적용한다면,

1) 먼저 프록시를 적용할 클래스인지 판단

2) 적용 대상 클래스인 경우엔 어드바이스를 적용할 메소드인지 확인 

> 클래스 자체가 프록시 적용 대상 아니라면, 어드바이스를 통한 부가기능 부여는 물 건너감.
> 
> 결국 이 두 가지 조건이 모두 충족되는 타깃의 메소드에 어드바이스 적용됨

<br>

### 🧐 ProxyFactoryBean VS DefaultAdvisorAutoProxyCreator
전자는 굳이 **클래스 레벨의 필터 필요없었음.**

후자는 모든 빈에 대해 프록시 자동 적용 대상을 선별해야하는 빈 후처리기이므로 **클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요.**
> 정확히는 그런 포인트컷과 어드바이스가 결합되어 있는 **어드바이저가 등록되어 있어야 함.**
> 
> 확장 포인트컷 기능 확인하는 학습 테스트 소스코드 p.480

<br>

## `DefaultAdvisorAutoProxyCreator`의 적용
### STEP 1️⃣  클래스 필터를 적용한 포인트컷 작성
- 메소드 이름만 비교하던 포인트컷인 `NameMatchMethodPointcut`을 상속해 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름 비교하는 ClassFilter를 추가하도록 만들자.
### STEP 2️⃣ 어드바이저를 이용하는 자동 프록시 생성기 등록
- 적용할 자동 프록시 생성기인 `DefaultAdvisorAutoProxyCreator`는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것 모두 찾음.

- 그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보며 프록시 적용 대상 선정함.
- 빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기함
#### Feat: `DefaultAdvisorAutoProxyCreator` 등록
```xml
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />
```
#### Feat: 포인트컷 등록
```xml
<bean id="transactionPointcut" class="springbook.service.NameMatchClassMethodPointcut">
	<property name="mappedClassName" value="*ServiceImpl" />
	<property name="mappedName" value="upgrade*" /> 
</bean>
```

### STEP 3️⃣ 어드바이스와 어드바이저 확인
어드바이스인 `transactionAdvice` 빈의 설정, 어드바이저인 `transactionAdvisor` 빈도 수정할 필요 X
#### 하지만, 어드바이저로서 사용되는 방법이 바뀌었음
- 전 : `ProxyFactoryBean`으로 등록한 빈에서처럼 `transactionAdvisor`를 명시적으로 DI하는 빈은 존재하지 X
- 후 : **어드바이저를 이용하는 자동 프록시 생성기인 `DefaultAdvisorAutoProxyCreator`에 의해 자동수집**되고, **프록시 대상 선정 과정에 참여**하며, **자동생성된 프록시에 다이내믹하게 DI 돼서 동작하는 어드바이저가 됨**

### STEP 4️⃣ ProxyFactoryBean 제거와 서비스 빈의 원상복구
- userServiceImpl 빈의 아이디를 userService로 되돌려놓자.
- ProxyFactoryBean 타입의 빈은 삭제하자.

### STEP 5️⃣ 자동 프록시 생성기를 사용하는 테스트
- 자동 프록시 생성기라는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 테스트 대상도 빈으로 등록해줄 필요가 있음.

#### 💥 기존에 만들어서 사용하던 강제 예외 발생용 TestUserService 클래스를 이젠 직접 빈으로 등록할 때 생기는 두 가지 문제
1) TestUserService가 UserServiceTest의 클래스의 내부에 정의된 스태틱 클래스라는 점 

2) 포인트컷이 트랜잭션 어드바이스를 적용해주는 대상 클래스의 이름 패턴이 *ServiceImpl라고 되어 있어 TestUserService 클래스는 빈으로 등록을 해도 포인트컷이 프록시 적용대상으로 선정해주지 않는다는 점

#### ✅ 해결책 : TestUserService 스태틱 멤버 클래스를 수정하자. 
- 클래스 이름을 TestUserServiceImpl로 변경

- 아예 예외를 발생시킬 대상인 네 번째 사용자 아이디를 클래스에 넣기
- TestUserServiceImpl을 빈으로 등록
- **testUserService 빈 설정 특이한 사항 두 가지** :
	- `$` 기호 : 스태틱 멤버 클래스를 지정할 때 사용

	- `parent` 애트리뷰트 : `<bean>` 태그에 `parent` 애트리뷰트를 사용하면 다른 빈 설정의 내용 상속받을 수 있음
- `upgradeAllOrNothing()` 테스트를 새로 추가한 `testUserService` 빈을 사용하도록 수정
- 소스코드 p.485~486

### STEP 6️⃣ 자동생성 프록시 확인
지금까지 트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 매커니즘을 통해 적용함.

최소한 두 가지는 확인해야 함.
1. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가 -> 🙆‍♀️ `upgradeAllOrNothing()` 테스트를 통해 검증함

2. 아무 빈에나 트랜잭션이 부가기능이 적용된 것은 아닌지 확인 (즉, 클래스 필터가 제대로 동작해서 프록시 생성 대상을 선별하고 있는지 여부 확인)
>**✔ 확인 방법** (코드 p.488)
> - 방법1) 포인트컷 빈의 클래스 이름 패턴 변경해 이번엔 `testUserService` 빈에 트랜잭션이 적용되지 않게 해보기
>
>- 방법2) 자동생성된 프록시를 확인

<br>
이번에는 좀 더 편리한 포인트컷 작성 방법을 알아보자.

## 포인트컷 표현식을 이용한 포인트컷
#### 지금까지 사용했던 포인트컷 : 
- 메소드의 이름과 클래스의 이름 패턴을 각각 클래스 필터와 메소드 매처 오브젝트로 비교해 선정하는 방식

#### 🧐 이보다 더 복잡 + 세밀한 기준 이용해 클래스나 메소드를 선정하게 하려면?
>🙋‍♀️ 포인트컷 표현식을 이용하자!

<br>

## ✅ 포인트컷 표현식
🌱 스프링은 아주 간단 + 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공함.

**포인트컷 표현식** : **정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해 포인트컷을 작성할 수 있도록 하는 방법**

- 포인트컷 표현식을 지원하는 포인트컷을 적용하는 방법 : `AspectJExpressionPointcut` 클래스 사용하면 됨

- `Pointcut` 인터페이스를 구현해야 하는 스프링의 포인트컷은 클래스 필터와 메소드 매처 두 가지를 각각 제공해야 함.
- `AspectJExpressionPointcut`은 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해줌.
- 자바의 RegEx 클래스가 지원하는 정규식처럼 간단한 문자열로 복잡한 선정조건을 쉽게 만들어낼 수 있는 강력한 표현식을 지원함
- 스프링이 사용하는 포인트컷 표현식은 AspectJ라는 유명한 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해 사용하는 것 => 그래서 **AspectJ 포인트컷 표현식**이라고도 함.

<br>

### ✅ 포인트컷 표현식 문법
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성함.

가장 대표적으로 사용되는 것 : `execution()`
- `[]` 괄호는 옵션항목 (생략 가능하다는 의미)
- `|` 는 OR 조건

```java
execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])

// 출력 결과 예시
public int springbook.learningtest.spring.pointcut.Target.minus(int, int) throws java.lang.RuntimeException
```
#### `public` : 접근제한자 패턴(public, protected, private 등 올 수 있음), 생략 가능
- 생략 가능 = 조건을 부여하지 않는다는 의미

#### `int` : 리턴 값의 타입 패턴, 필수 항목
- `*`를 써서 모든 타입 다 선택하겠다고 해도 됨
#### `springbook.learningtest.spring.pointcut.Target` : 패키지와 타입 이름을 포함한 클래스의 타입패턴, 생략 가능
- 생략 가능 = 모든 타입 다 허용하겠다는 뜻

- 패키지 이름과 클래스 또는 인터페이스 이름에 `*` 사용 가능
- `..` 를 사용하면 한 번에 여러 개의 패키지 선택 가능
 
#### minus : 메소드 이름패턴, 필수 항목
- 모든 메소드를 다 선택하겠다면 `*` 넣으면 됨

#### (int, int) : 메소드 파라미터의 타입 패턴, 필수 항목
- 메소드 파라미터의 타입을 `,` 로 구분하면서 순서대로 적으면 됨.
- 파라미터가 없는 메소드 지정하고 싶을 경우 `()` 로 적음
- 파라미터의 타입, 개수에 상관없이 모두 다 허용하고 싶으면 `..` 넣으면 됨
- `...` 이용해 뒷부분의 파라미터 조건만 생략 가능

#### throws java.lang.RuntimeException : 예외 이름에 대한 타입 패턴, 생략 가능

#### 📝 추가할 라이브러리
```java
com.springsource.org.aspectj.tools-1.6.6.RELEASE.jar
```

`AspectJExpressionPointcut` 클래스의 오브젝트 만들고 포인트컷 표현식을 expression 프로퍼티에 넣어주면 포인트컷 사용할 준비가 됨.

포인트컷 표현식은 메소드 시그니처를 `execution()` 안에 넣어서 작성함.

#### 🤗 옵션항목 생략하면 다음과 같이 간단하게 만들 수 있음.
```java
execution(int minus(int, int)) // int 타입의 리턴 값, minus라는 메소드 이름, 두 개의 int 파라미터를 가진 모든 메소드를 선정하는 포인트컷 표현식
```
> 생략한 부분은 모든 경우를 다 허용하도록 되어 있음.

#### 가장 느슨한 포인트컷 
```java
execution(* *(..)) // 리턴 타입, 파라미터, 메소드 이름에 상관없이 모든 메소드 조건을 다 허용하는 포인트컷 표현식
```

<br>

### 포인트컷 표현식은 메소드의 시그니처를 비교하는 방식인 `execution()` 외에도 몇 가지 표현식 스타일 갖고 있음.
#### 1️⃣ `bean()` 
- 스프링에서 사용될 때 빈의 이름으로 비교

- 단지 클래스와 메소드라는 기준 넘어서는 유용한 선정 방식
```java
bean(*Service) // 아이디가 Service로 끝나는 모든 빈을 선택
```
#### 2️⃣ 특정 애노테이션 
- 특정 애노테이션이 타입, 메소드, 파라미터에 적용되어 있는 것을 보고 메소드를 선정하게 하는 포인트컷

- 까다로운 명명 규칙 사용하지 않아도, 애노테이션만 부여해놓고 포인트컷 통해 자동으로 선정해 부가기능을 제공하게 해주는 방식
- 스프링 내에서도 애용되는 편리한 방식
```java
@annotation(org.springframework.transaction.annotation.Transactional) // @Transactional이라는 애노테이션이 적용된 메소드를 선정하게 해줌.
```

<br>

### 포인트컷 표현식을 이용하는 포인트컷 적용
STEP 1️⃣ 앞에서 만든 transactionPointcut 빈은 제거하자

STEP 2️⃣ 기존 포인트컷과 동일한 기준으로 메소드를 선정하는 알고리즘을 가진 포인트컷 표현식을 만들자

STEP 3️⃣ 설정파일 수정했으면 UserServiceTest 테스트를 실행해 포인트컷이 이전과 동일하게 동작하는지 확인해보자

<br>

### 포인트컷 표현식 장단점
장점 : 코드와 설정이 모두 단순해짐

단점 : 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않음
> 충분히 학습하고, 다양한 테스트를 미리 만들어서 검증한 표현식을 가져다 사용하자

<br>

## AOP란 무엇인가?
지금까지 비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리해보자.

1. 트랜잭션 서비스 추상화

2. 프록시와 데코레이터 패턴 적용
3. 다이내믹 프록시와 프록시 팩토리 빈 
4. 자동 프록시 생성 방법과 포인트컷
	☑ 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈 설정해줘야 한다는 부담 해결
	
	☑ 트랜잭션 부가기능 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리 가능
	
	☑ 간단한 설정만으로 적용 대상을 손쉽게 선택 가능

>트랜잭션 경계설정 기능은 다른 모듈의 코드에 부가적으로 부여되는 기능이기 때문에, 
트랜잭션 코드는 한데 모을 수 없고, 애플리케이션 전반에 여기저기 흩어져 있음.
>
>따라서, 트랜잭션 경계설정 기능을 독립된 모듈로 만들려면 다이내믹 프록시 또는 빈 후처리 기술과 같은 복잡한 기술 요구됨.
>
>트랜잭션 부가기능이란 트랜잭션 기능을 추가해줄 다른 대상, 즉 타깃이 존재해야만 의미 있음.
>
>기능이 부여되는 타깃은 애플리케이션의 핵심기능.
>
>부가기능은 여타 핵심기능과 같은 레벨에서는 독립적으로 존재하는 것 자체가 불가능.

#### 🤔 핵심기능을 담당하는 코드 여기저기에 흩어져 나타나야 했던 부가기능을 어떻게 독립적인 모듈로 만들 수 있을까? 
- 지금까지 살펴본 **DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷**과 같은 기법이 이런 문제를 해결하기 위해 적용한 대표적인 방법
=> 덕분에 부가기능인 트랜잭션 경계설정 기능은 `TransactionAdvice`라는 이름으로 모듈화될 수 있었음.

- 독립적으로 모듈화했을 때의 장점 
	- 코드는 중복되지 X, 변경 필요한 곳 한 곳만 수정하면 됨

	- 부가기능을 부여할 대상 선정 가능
	- 핵심기능을 담은 코드와 설정에는 전혀 영향 주지 않아도 됨

<br>

#### [결론]
지금까지 해온 모든 작업은 **핵심기능에 부여되는 부가기능을 효과적으로 모듈화하는 방법을 찾는 것**이었고, 어드바이스와 포인트컷을 결합한 **어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어지게 됨**

<br>

## AOP: 애스팩트 지향 프로그래밍
트랜잭션 경계설정과 같은 부가기능을 어떻게 모듈화할 것인가 연구해온 사람들은 이 부가기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다고 생각함.

그래서 이런 부가기능 모듈을 객체지향 기술에서 주로 사용하는 오브젝트와는 다르게 **특별한 이름**으로 부르기 시작함
> **애스펙트(aspect)**

<br>

### ✅ 애스펙트(aspect)
**그 자체로 애플리케이션의 핵심기능을 담고 있진 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킴**

- 애스펙트는 부가될 기능을 정의한 코드인 **어드바이스**와, 어드바이스를 어디에 적용할지 결정하는 **포인트컷**을 함께 갖고 있음.

	- 지금 사용하고 있는 **어드바이저는 아주 단순한 형태의 애스펙트**라고 볼 수 있음.
- 애스펙트는 그 단어의 의미대로 **애플리케이션을 구성하는 한 가지 측면**이라고 생각 가능

#### 애스펙트로 분리할 경우 장점 :
- 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고, 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 됨

<br>

### ✅ AOP(Aspect Oriented Programming, 애스펙트 지향 프로그래밍)
**애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법**
- **OOP를 돕는 보조적인 기술**이지 OOP를 완전히 대체하는 새로운 개념 X

- AOP는 애스펙트를 분리함으로써 **핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것**
- AOP는 결국 애플리케이션을 **다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것**
	- 트랜잭션 기술의 적용에만 주목하고 싶다면, `TransactionAdvice`에만 집중하고, 그 대상을 결정해주는 `transactionPointcut` 빈의 설정만 신경 써주면 됨
- 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 **관점 지향 프로그래밍**이라고도 함

<br>

##  AOP 적용기술
### 1️⃣ 프록시를 이용한 AOP (스프링의 AOP)
🌱 스프링은 IoC/DI 컨테이너와 다이내믹 프록시, 데코레이터 패턴, 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술 조합해 AOP를 지원 중

가장 핵심은 **프록시**를 이용했다는 것.

>스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외엔 특별한 기술이나 환경 요구 X
>
>스프링 컨테이너인 애플리케이션 컨텍스트는 특별한 환경이나 JVM 설정 등을 요구 X

스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상 : "**오브젝트의 메소드**"

독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할맡고 있는 게 프록시

**스프링의 AOP는 프록시 방식의 AOP** 

### 2️⃣ 바이트코드 생성과 조작을 통한 AOP (AspectJ)
AOP 기술의 원조이자 가장 강력한 AOP 프레임워크로 꼽히는 `AspectJ`

`AspectJ`는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법 사용.

#### 🧐왜 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용할까?
- 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용가능하기 때문

- 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능 (오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능 부여 가능)

<br>

### [결론]
**일반적인 AOP를 적용하는 데는 프록시 방식의 스프링 AOP로도 충분함**

간혹 **특별한 AOP 요구사항이 생겨 스프링의 프록시 AOP 수준을 넘어서는 기능이 필요**하다면, 그땐 **AspectJ를 사용**하면 됨

**스프링 AOP를 기본적으로 사용하면서 동시에 AspectJ 이용 가능**

<br>

## AOP 용어 정리
### ✅ 타깃
- **부가기능을 부여할 대상**

- 핵심기능을 담을 클래스일 수도 있지만, 경우에 따라선 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있음

<br>

### ✅ 어드바이스
- **타깃에게 제공할 부가기능을 담은 모듈**

- 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있음
- 어드바이스 종류 : 
	- 메소드 호출 과정에 전반적으로 참여하는 어드바이스 (ex. MethodInterceptor)

	- 메소드 호출 과정 일부에서만 동작하는 어드바이스 (ex. 예외가 발생했을 때만 동작하는 어드바이스)

<br>

### ✅ 조인 포인트(join point)
- **어드바이스가 적용될 수 있는 위치**

- 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐
- 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 됨

<br>

### ✅ 포인트컷
- **어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈**

- 스프링 AOP의 조인 포인트는 메소드의 실행이므로 **스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있음.** 
- 그래서 포인트컷 표현식은 메소드의 실행이라는 의미인 `execution`으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 사용함
- 메소드는 클래스 안에 존재하는 것이기 때문에 메소드 선정이란 결국 클래스를 선정하고, 그 안에 메소드를 선정하는 과정을 거치게 됨

<br>

### ✅ 프록시
- **클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트**

- **DI를 통해 타깃 대신 클라이언트에게 주입**되며, **클라이언트의 메소드 호출을 대신 받아서 타깃에 위임**해주면서, **그 과정에서 부가기능을 부여**함. 
- 스프링은 프록시를 이용해 AOP를 지원함

<br>

### ✅ 어드바이저
- **포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트**

- 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈
- 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보로 활용함
- 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고, 일반적인 AOP에서는 사용되지 X

<br>

### ✅ 애스펙트
- **AOP의 기본 모듈**

- **한 개 또는 그 이상의 포인트컷과 어드바이스의 조합**으로 만들어지며 **보통 싱글톤 형태의 오브젝트**로 존재함
- 따라서, 클래스와 같은 모듈 정의와 오브젝트와 같은 실체(인스턴스)의 구분이 특별히 없음
- **스프링의 어드바이저**는 **아주 단순한 애스펙트**라고 볼 수 있음

<br>

### 👀 스프링의 프록시 방식 AOP 적용하려면 최소한 네 가지 빈을 등록해야 함
#### 1️⃣ 자동 프록시 생성기
> 스프링의 `DefaultAdvisorAutoProxyCreator` 클래스를 빈으로 등록
#### 2️⃣ 어드바이스
> 부가기능을 구현한 클래스를 빈으로 등록
#### 3️⃣ 포인트컷
> 스프링의 `AspectJExpressionPointcut`을 빈으로 등록하고, `expression` 프로퍼티에 포인트컷 표현식을 넣기
#### 4️⃣ 어드바이저
> 스프링의 `DefaultPointcutAdvisor` 클래스를 빈으로 등록해서 사용

<br>

### 🌱 스프링은 이렇게 AOP를 위해 기계적으로 적용하는 빈들을 간편한 방법으로 등록 가능
> `aop` 스키마에 정의된 태그들을 사용하자
> 
> 관련 코드 p.511
 
<br>

## 6.6 트랜잭션 속성
### 트랜잭션 정의
**더 이상 쪼갤 수 없는 최소 단위의 작업**

트랜잭션 경계 안에서 진행된 작업은 `commit()` 통해 모두 성공하든지, 아니면 `rollback()` 통해 모두 취소돼야 함

그런데, 이 밖에도 트랜잭션의 동작방식을 제어할 수 있는 몇 가지 조건 있음

`DefaultTransactionDefinition`이 구현하고 있는 `TransactionDefinition` 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는데, 네 가지 속성을 정의하고 있음.

### 속성 1️⃣ 트랜잭션 전파(transaction propagation)
- **트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식**

- 종류
	- `PROPAGATION_REQUIRED` : 진행 중인 트랜잭션이 없으면 새로 시작하고 이미 시작된 트랜잭션이 있으면 이에 참여함 (`DefaultTransactionDefinition` 에서는 이게 default)
	- `PROPAGATION_REQUIRES_NEW` : 항상 새로운 트랜잭션을 시작
	- `PROPAGATION_NOT_SUPPORTED` : 트랜잭션 없이 동작

<br>

### 속성 2️⃣ 격리수준(isolation level)
- **적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어** 
- `ISOLATION_DEFAULT` (`DefaultTransactionDefinition` 에서는 이게 default)

<br>

### 속성 3️⃣ 제한시간(timeout)
- **트랜잭션을 수행하는 제한시간 설정**
- 제한시간이 없음이 default

<br>

### 속성 4️⃣ 읽기전용(read only)
- **트랜잭션 내에서 데이터를 조작하는 시도 막을 수 있음 + 데이터 액세스 기술에 따라서 성능 향상될 수도 있음**

<br>

💥 하지만, 이 방법으로 트랜잭션 속성 변경하면, `TransactionAdvice`를 사용하는 모든 트랜잭션의 속성이 한꺼번에 바뀜

#### 🤔 원하는 메소드만 선택해서 독자적으로 트랜잭션 정의를 적용할 수 있는 방법은 없을까?

> #### ✅ 어드바이스의 기능을 확장하자!

<br>

### 트랜잭션 인터셉터와 트랜잭션 속성
#### ✅ 스프링의 `TransactionInterceptor`를 이용해보자.
- 동작방식은 기존에 만들었던 `TransactionAdvice`와 다르지 X

- 다만, **트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐임.**
- `TransactionInterceptor`의 두 가지 프로퍼티 : `PlatformTransactionManager`, `Properties 타입`
	- `Properties` 타입인 두 번째 프로퍼티의 이름 : `transactionAttributes` (트랜잭션 속성 정의)

<br>

🧐 런타임 예외만이 아니라 모든 종류의 예외에 대해 트랜잭션을 롤백시키도록 해야 할까? 
>X

#### 🌱 스프링이 제공하는 `TransactionInterceptor`에는 기본적으로 두 가지 종류의 예외 처리 방식이 있음
1. 런타임 예외가 발생하면 트랜잭션은 롤백됨

2. 타깃 메소드가 런타임 예외가 아닌 체크 예외를 던지는 경우엔 트랜잭션을 커밋함

#### <스프링의 기본적인 예외처리 원칙>
- 비즈니스적인 의미 있는 예외상황에만 체크 예외 사용, 그 외의 모든 복구 불가능한 순수한 예외의 경우는 런타임 예외로 포장돼서 전달하는 방식을 따른다고 가정함

**그런데, `TransactionInterceptor`의 이러한 예외처리 기본 원칙을 따르지 X 경우, `rollbackOn()` 이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다.**

<br>

### ✅ 메소드 이름 패턴을 이용한 트랜잭션 속성 지정
Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션임.

#### 트랜잭션 속성은 다음과 같은 문자열로 지정 가능
```java
PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2
```
> 트랜잭션 전파 항목만 필수, 나머진 다 생략 가능
>
>모든 항목이 구분 가능해서 순서 바꿔도 상관 X
>
> 트랜잭션 속성 중 readOnly나 timeout 등은 트랜잭션이 처음 시작될 때가 아니라면 적용되지 X

<br>

### tx 네임스페이스를 이용한 설정방법
- `TransactionInterceptor` 타입의 어드바이스 빈과 `TransactionAttribute` 타입의 속성 정보도 tx 스키마의 전용 태그를 이용해 정의 가능 (코드 p.520)

<br>

### ✅ 포인트컷 표현식과 트랜잭션 속성 정의 시 따르면 좋은 몇 가지 전략
- **트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.**

	- 가능하면 클래스보단 인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋음
- **공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.** 
	- 모든 메소드에 대해 디폴트 속성 지정, 개발이 진행됨에 따라 필요하면 속성 추가 

	- 일반화하기에는 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대해선 별도의 어드바이스와 포인트컷 표현식을 사용하는 편이 좋음
- 👽 **프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.**
	- **타깃 안에서의 호출에는 프록시가 적용되지 않는 문제 해결 방안** : AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용 (꼭 필요한 경우에만 사용해)

<br>

### 👩‍💻 트랜잭션 속성과 그에 따른 트랜잭션 전략을 UserService에 적용
소스 코드 p.527 ~ p.531

STEP 1) 트랜잭션 경계설정의 일원화 (특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직)

STEP 2) 서비스 빈에 적용되는 포인트컷 표현식 등록

STEP 3) 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록

STEP 4) 트랜잭션 속성 테스트

<br>

## 6.7 애노테이션 트랜잭션 속성과 포인트컷
가끔 클래스나 메소드에 따라 제각각 속성이 다른, 세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우, 메소드 이름 패턴 이용해서 일괄적으로 트랜잭션 속성을 부여하는 방식은 부적합함.
> 🤗 **스프링은 직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정하는 방법**을 제공함

<br>

### ✅ 트랜잭션 애노테이션 `@Transactional`
- `@Transactional` 애노테이션의 타깃 : 메소드와 타입
	- 메소드, 클래스, 인터페이스 사용 가능

- 위 애노테이션을 트랜잭션 속성정보로 사용하도록 지정하면 스프링은 `@Transactional` 이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식
- 사용되는 포인트컷은 `TransactionAttributeSourcePointcut` 
	- 스스로 표현식과 같은 선정기준 갖고 있지 x

	- 대신 `@Transactional` 이 타입 레벨이든 메소드 레벨이든 상관없이 부여된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려줌
- `@Transactional`은 기본적으로 트랜잭션 속성을 정의하는 것이지만, 동시에 포인트컷의 자동등록에도 사용됨.

- #### `@Transactional` 장점 : 포인트컷과 트랜잭션 속성을 애노테이션 하나로 지정 가능

<br>

#### 트랜잭션 부가기능 적용 단위는 메소드 -> 메소드마다 `@Transactional` 부여하고 속성 지정 가능
- 장점 : 유연한 속성 제어

- 단점 : 코드 지저분, 동일한 속성 정보 가진 애노테이션 반복적으로 메소드마다 부여 => ✅ `@Transactional` 적용할 때 **4단계의 대체 정책** 이용하자

<br>

### ✅ 대체 정책
- **메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입(클래스, 인터페이스)의 순서에 따라 `@Transactional` 이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법**
#### `@Transactional` 대체 정책의 예
```java
[1]
public interface Service {
	[2]
	void method1();
	[3]
	void method2();
}
[4]
public class ServiceImpl implements Service{
	[5]
	public void method1(){
	}
	[6]
	public void method2(){
	}
}
```
> 📝 확인 순서 : 
> - [5]와 [6]
> 
> - [4]
> - [2]와 [3]
> - [1]

>안전하게 타깃 클래스에 `@Transactional`을 두는 방법을 권장

<br>

### ✅ 트랜잭션 애노테이션 사용을 위한 설정
```xml
<tx:annotation-driven />
```
### 👩‍💻 트랜잭션 애노테이션 적용 p.537 ~ p.538

<br>

## 6.8 트랜잭션 지원 테스트
### ✅ 선언적 트랜잭션(declarative transaction)
AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법

### ✅ 프로그램에 의한 트랜잭션(programmatic transaction)
TransactionTemplate이나 개별 데이트 기술의 트랜잭션 API르 사용해 직접 코드 안에서 사용하는 방법

<br>

🌱 스프링은 이 두 가지 방식을 모두 지원하고 있음.

물론 특별한 경우가 아니라면, **선언적 방식의 트랜잭션을 사용하는 것이 바람직**함.

### 트랜잭션 동기화와 테스트
- **트랜잭션의 자유로운 전파와 그로 인한 유연한 개발이 가능할 수 있었던 기술적 배경** : 1) AOP 2)스프링의 트랜잭션 추상화
	- **AOP** 덕분에 **프록시 이용한 트랜잭션 부가기능을 간단하게 애플리케이션 전반에 적용 가능**

	- **트랜잭션 추상화** 덕분에 **AOP를 통한 선언적 트랜잭션이나 트랜잭션 전파 가능**

<br>

### 트랜잭션 추상화 기술의 핵심
#### 1️⃣ 트랜잭션 매니저
- PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했음

#### 2️⃣ 트랜잭션 동기화
- 트랜잭션 동기화 기술이 있었기에 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유 가능했음

- 트랜잭션 전파를 위해서도 중요한 역할을 함

<br>

### 🤔 테스트 메소드에서 만들어지는 세 개의 트랜잭션을 하나로 통합할 수는 없을까?
세 개의 메소드 모두 트랜잭션 전파 속성이 `REQUIRED`이니 이 메소드들이 호출되기 전에 트랜잭션이 시작되게만 한다면 가능함.

그런데, **메소드를 추가하지 않고도 테스트 코드만으로 세 메소드의 트랜잭션을 통합하는 방법** 있음.
> ✅ **테스트 메소드에서 UserService의 메소드를 호출하기 전에 트랜잭션을 미리 시작해주면 됨**
> - 트랜잭션의 전파는 트랜잭션 매니저를 통해 트랜잭션 동기화 방식이 적용되기 때문에 가능하다고 했음. 
> 
> - 그렇다면, 테스트에서 트랜잭션 매니저를 이용해 트랜잭션을 시작시키고 이를 동기화해주면 됨
> - 소스 코드 p.544

트랜잭션이라면 당연히 롤백도 가능해야 함.
### ✅ 롤백 테스트
- **테스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법**

- 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고 테스트가 끝나면 무조건 롤백해버리는 테스트를 말함. 
- 소스 코드 p.547

#### 롤백 테스트의 장점 :
- 테스트를 진행하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어줌 -> 매 테스트마다 처음과 동일한 User 테이블의 테스트 데이터로 테스트를 수행 가능

- 여러 개발자가 하나의 공용 테스트용 DB를 사용할 수 있게 해줌 

#### 테스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 큰 유익 = 롤백 테스트

<br>

## 테스트를 위한 트랜잭션 애노테이션
`@Transactional` 애노테이션을 타깃 클래스 또는 인터페이스에 부여하는 것만으로도 트랜잭션을 적용해주는 건 매우 편리한 기술임.

이 편리한 방법을 테스트 클래스와 메소드에도 적용 가능

### 🌱 스프링의 컨텍스트 테스트 프레임워크는 애노테이션을 이용해 테스트를 편리하게 만들 수 있는 여러 가지 기능을 추가하게 해줌.
> `@ContextConfiguration` : 
> - 클래스에 부여하면 테스트를 실행하기 전에 스프링 컨테이너를 초기화하고, `@Autowired` 애노테이션이 붙은 필드를 통해 테스트에 필요한 빈에 자유롭게 접근 가능

<br>

### ✅ 테스트에서 `@Transactional` 
- 테스트 클래스 또는 메소드에 `@Transactional` 애노테이션을 부여해주면 마치 타깃 클래스나 인터페이스에 적용된 것처럼 테스트 메소드에 트랜잭션 경계가 자동으로 설정됨 -> **테스트 내에서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있음**
- #### 👽 테스트에 적용된 `@Transactional`은 기본적으로 트랜잭션을 강제 롤백시키도록 설정되어 있음.

<br>

### ✅ `@Rollback`
- 테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶긴 하지만, 강제 롤백을 원하지 않을 경우 사용하면 됨

- `@Rollback`의 기본 값은 true
- 따라서, 트랜잭션은 적용되지만 롤백을 원치 않는다면 `@Rollback(false)` 라고 해줘야 함

<br>

### ✅ `@TransactionConfiguration`
- 테스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 모든 트랜잭션이 롤백되지 않고 커밋되게 하고 싶을 경우 사용하면 됨
- `@TransactionConfiguration` 사용하면 롤백에 대한 공통 속성을 지정 가능 

	- 디폴트 롤백 속성은 false로 해놓고, 테스트 메소드 중에서 일부만 롤백 적용하고 싶으면 메소드에 `@Rollback` 부여해주면 됨
#### `@TransactionConfiguration` 사용 예시
```java
...
@TransactionConfiguration(defaultRollback=false)
public class UserServiceTest{
	@Test
	@Rollback
	public void add() throws SQLException {...}
	...
}
```
<br>

대부분의 메소드에서 트랜잭션이 필요하다면 테스트 클래스에 `@Transactional`을 지정하는 게 편리함.

### 🧐 이 때, 굳이 트랜잭션이 필요 없는 메소드는 어떻게 해야 할까?
#### 방법 1️⃣ `@NotTransactional` 
- 테스트 메소드에 부여하면 클래스 레벨의 `@Transactional` 설정 무시하고 트랜잭션 시작하지 않은 채로 테스트 진행. 그런데, 스프링 3.0에서 제거 대상 됐기 때문에 사용하기 조금 꺼림칙함 😅
#### 방법 2️⃣ `@Transactional(propagation=Propagation.NEVER)` (이걸 추천)

<br>

일반적으로 의존, 협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하는 단위 테스트와, DB같은 외부의 리소스나 여러 계층의 클래스가 참여하는 통합 테스트는 **아예 클래스를 구분해서 따로 만드는 게 좋음.**

**DB가 사용되는 통합 테스트**를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레벨에 `@Transactional`을 부여해주는데, **DB가 사용되는 통합 테스트는 가능한 한 롤백 테스트로 만드는 게 좋음**

#### [결론]
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴 이용하는 방법과 타깃에 직접 부여하는 `@Transactional` 애노테이션을 사용하는 방법이 있다.

- `@Transactional` 을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다