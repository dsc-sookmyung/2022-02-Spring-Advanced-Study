# 📗 토비의 스프링 3.1 Vol.1 스프링의 이해와 원리
## 📝 1장 오브젝트와 의존관계
### 🌱 스프링
- 자바 기반으로 한 기술
- 스프링이 자바에서 가장 중요하게 가치 두는 것 : `객체지향 프로그래밍이 가능한 언어`
- 스프링의 핵심 철학 : 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치 회복 -> 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자 => 스프링이 가장 관심 많이 두는 대상 🧐 : `오브젝트`

#### ✨ 1장에서 집중해서 봐야 하는 것  : 오브젝트의 설계와 구현, 동작원리
<br> 

## 1.1 초난감 DAO 
### ✅ DAO(Data Access Object) 란? 

> - DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 `오브젝트`
> - DAO 핵심 기능 : **어떻게 데이터를 등록하고 가져올 것인가**(SQL 작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)
### ✅ 자바빈(JavaBean) 
> 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말함.
> 이제는 자바빈이라고 말하면, 비주얼 컴포넌트라기 보단 `디폴트 생성자`, `프로퍼티` 따라 만들어진 오브젝트를 가리킴. 간단히 `빈`이라고도 부름
> 
### ✅ 디폴트 생성자
> 자바빈은 **파라미터가 없는 디폴트 생성자**를 갖고 있어야 함.    
>  툴 또는 프레임워크에서 *리플렉션* 을 이용해 오브젝트를 생성하기 때문에 필요.
> - *리플렉션(Reflection) : 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API*

	 
### ✅ 프로퍼티

> **자바빈이 노출하는 이름을 가진 속성.**  
> 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있음.

<br> 

## 1.2 DAO의 분리
객체지향의 세계에서는 모든 것이 변한다.

변수나 오브젝트 필드의 값이 변한다는 게 아니라, **오브젝트에 대한 설계와 이를 구현한 코드가 변한다**는 뜻이다.

개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 **미래의 변화를 어떻게 대비할 것인가** 이다.
#### 🧐 객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유?
> 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적 특징 때문.
> 
> 객체 지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨짐. 
> 
> 하지만, 그보다는 `객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성`할 수 있고, 이를 `자유롭게 편리하게 변경, 발전, 확장시킬 수 있다`는 데 더 의미가 있음!     
#### 그러면 어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 
> #### 🙋 분리와 확장을 고려한 설계  
<br>
 
### ✅ 분리
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 `한 가지 관심이 한 군데에 집중되게 하는 것`

즉, 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

> 프로그래밍 기초 개념 중 **'관심사의 분리(Separation of Concerns)'** 를 객체지향에 적용해보면, `관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것`이라고 생각할 수 있음.
##
### 👀 UserDao의 관심사항
(UserDao 코드는 p. 56에 있음)
 1. **DB와 연결을 위한 커넥션을 어떻게 가져올까**
 
 3.  **사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것**
 
 5. **작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유 리소스를 시스템에 돌려주는 것**

##
 ### 👀 UserDao의 관심사항 - 1. DB와 연결을 위한 커넥션을 어떻게 가져올까
 - #### 🤦‍♀️ 문제 사항 1 : DB 커넥션 가져오는 코드 중복
 - #### ✅ 해결 방법 : 중복 코드를 독립적인 메소드로 분리 = called '메소드 추출(extract method) 기법' in 리팩토링
	- ✅ 리팩토링(refactoring) : 
		
		> - 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술   
		> - 리팩토링을 하면 코드 내부의 설계 개선 -> 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응 가능 -> 생산성 ⬆️, 코드 품질 ⬆️, 유지보수하기 용이, 견고+유연한 제품 개발 가능😊   
		> - 리팩토링이 절실히 필요한 코드의 특징 = called '나쁜 냄새'     
				 ex. 중복된 코드

 - #### 🤦‍♀️ 문제 사항 2 : if N사와 D사가 각기 다른 종류의 DB 사용하고 있고, DB 커넥션 가져오는데 있어 독자적으로 만든 방법 적용하고 싶어함. 근데 소스코드 공개하고 싶지는 않아 .. 
 - #### ✅ 해결 방법 : 상속을 통해 서브클래스로 분리
	> 쉽게 말하자면, 만들어놨던 메소드의 구현 코드를 제거하고 추상 메소드로 만들고 메소드 구현은 서브클래스가 담당하도록 하라는 이야기
		
	>  이렇게 슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법 
	>
	>= called **템플릿 메소드 패턴(template method pattern)** in 디자인 패턴   

	- #### ✅ 템플릿 메소드 패턴(template method pattern)
		> - 스프링에서 애용되는 디자인 패턴
		> - 책에 있는 예시로 설명해보자면, 
		> 	- UserDao의 getConnection() 메소드 : Connection 타입 오브젝트를 생성한다는 기능 정의해놓은 추상 메소드
		> 	- UserDao의 서브클래스의 getConnection() 메소드 : 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법
		> - 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것 = **팩토리 메소드 패턴(factory method pattern)** 이라고 부르기도 함.
		> 	- **UserDao**는 **어떤 기능을 사용한다**는 데에만 관심 있고, **NUserDao나 DUserDao**에서는 **어떤 식으로 Connection 기능을 제공하는지, 어떤 방법으로 Connection 오브젝트를 만들어내는지**에 관심을 두고 있는 것.

	> 그러니까 지금까지 설명한 것들이 "UserDao에 팩토리 메소드 패턴을 적용해서 getConnection()을 분리합시다"라는
	> 한마디와 같다😅
	
	<br>
	
	### 그러나, 이 방법은 **단점**이 있음. 
	### 바로 **상속을 사용했다**는 점이다. 
	> #### 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있으면 어쩔 것인가? 🤷‍♀️
	> 
	> 	 - **자바는 클래스의 다중상속을 허용하지 않는다.** 
	> 	 - **상속을 통한 상하위 클래스의 관계는 생각보다 밀접**함.
	> 	 -  **확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것**도 단점
	>
	> 		 - 만약, UserDao 외의 DAO 클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 **getConnection()의 구현 코드가 매 DAO 클래스마다 중복되어 나타나**는 심각한 문제 발생 💥

<br> 

## ➕ 디자인 패턴에 대하여 
### 📚 디자인 패턴 
- **소프트웨어 설계 시 특정 상황에서 자주 만나는 문제 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션**
- 주로 객체지향 설계에 관한 것이고, 대부분 객체지향적 설계 원칙을 이용해 문제 해결함. 
- 패턴 설계 구조 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문  

	> 	**1. 클래스 상속**   
	>
	> 	**2. 오브젝트 합성**
- 패턴에서 가장 중요한 것 : **각 패턴의 핵심이 담긴 목적 또는 의도**
- **패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지 기억**해둬야 함.  


	### 📙 템플릿 메소드 패턴
	- **상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법**
		> 	- 변하지 않는 기능 : 슈퍼클래스
		> 	- 자주 변경되며 확장할 기능 : 서브클래스에서 만들도록 함

		> 	- 슈퍼클래스에서는 **미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의**해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 **템플릿 메소드**를 만듦.      
		> 	- 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 `훅(hook) 메소드`라고 함.
		
		> 	- 서브클래스에서는 **추상 메소드를 구현**하거나, **훅 메소드를 오버라이드**하는 방법을 이용해 기능의 일부를 확장함.

	### 📘 팩토리 메소드 패턴
	- **템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴**
		> 그래서 구조도 비슷함.
	

		> - 슈퍼클래스 코드에서는 **서브클래스에서 구현할 메소드를 호출해 필요한 타입의 오브젝트를 가져와 사용**함.
		> 	- 이 메소드는 **주로 인터페이스 타입**으로 **오브젝트를 리턴**하므로 **서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서 알지 못함.**
		> 	- 사실 관심도 없음

	
		
		> - 서브클래스는 다양한 방법으로 **오브젝트를 생성하는 메소드 재정의 가능**
		> 	- 이렇게 **서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드**를 `팩토리 메소드`라고 함.

	- 이 방식을 통해 **오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법**을 **팩토리 메소드 패턴**이라고 함. 
	- 자바에서는 종종 오브젝트를 생성하는 기능을 가진 메소드를 일반적으로 팩토리 메소드라고 부르기도 함. *이 때 말하는 팩토리 메소드와 팩토리 메소드 패턴의 팩토리 메소드는 의미가 다르므로 혼동하지 않도록 주의!* 
<br>

## 1.3 DAO의 확장
관심사에 따라 분리한 오브젝트들은 제각기 독특한 변화 특징 있음.  

### 🧐 변화의 성격이 다르다? 
> **변화의 이유와 시기, 주기 등이 다르다는 뜻**

#### 지금까지 나왔던 해결 방법

> 첫 번째 : 독립된 메소드를 만들어 분리  
> 두 번째 : 상하위 클래스로 분리

### 세 번째 해결 방법
 **아예 상속관계도 아닌 완전히 독립적인 클래스로 만들자!**  

>  DB 커넥션과 관련된 부분을 서브 클래스가 아니라, 아예 별도의 클래스에 담고, 이렇게 만든 클래스를 UserDao가 이용하게 하면 됨.
>  
💥 근데 이렇게 하면 N 사와 D 사에 UserDao 클래스만 공급하고 상속 통해 DB 커넥션 기능 확장해서 사용했던 게 다시 불가능해짐. 

이렇게 클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 **두 가지 문제 해결해야 함.**
> **문제 1. 독립적으로 만든 클래스의 메소드**   
> 
> **문제 2. DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 함.**

#### 상속을 이용한 방법만도 못한 게 아닌가 싶다. 😂
#### 그렇다면, 클래스를 분리하면서도 이런 문제를 해결하는 방법은?

> ✨ 가장 좋은 해결책 : **두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것.**
> 
<br>

### ✅ 추상화

> 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업.  
> 
> 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 **인터페이스** 

### ✅ 인터페이스

> 어떤 일을 하겠다는 기능만 정의해놓은 것.
> 
> - 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버림. 
> 결국 오브젝트를 만들려면, 구체적인 클래스 하나를 선택해야겠지만 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에선 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 됨. 
> 
> - **인터페이스를 통해 접근하게 되면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.**

#### 그런데 인터페이스를 사용했을 때의 문제점 : 
- 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아있음. 😡

이 관심은 .. UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심.

<br> 

## 🧐 서비스 VS 클라이언트
> ### 서비스 : 사용되는 오브젝트
> ### 클라이언트 : 사용하는 오브젝트

> ex. UserDao의 클라이언트 오브젝트가 제3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳

=> UserDao의 **클라이언트에서 UserDao를 사용하기 전에,** 먼저 **UserDao가 어떤 ConnectionMaker의 구현 클래스를 사용할지를 결정하도록 만들어보자.**

즉, **UserDao 오브젝트**와 특정 클래스로부터 만들어진 **ConnectionMaker 오브젝트 사이에 관계를 설정**해주는 것.

클래스 사이의 관계를 설정해주는 건 x

클래스 사이의 관계가 만들어진다 = 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻

따라서 클래스가 아니라 **오브젝트와 오브젝트 사이의 관계를 설정**해줘야 함.
<br>

#### HOW?
**런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식**으로 만들어진다.

> ### ex. `connectionMaker = new DConnectionMaker();` 
> DConnectionMaker의 오브젝트의 레퍼런스를 UserDao의 connectionMaker 변수에 넣어서 사용하게 함 
> 
> => 이 두 개의 오브젝트가 '사용'이라는 관계 맺게 해줌.
> 
>**외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용하면 됨.**
> ####  if **파라미터의 타입**을 **전달받을 오브젝트의 인터페이스로 선언**해두었다고 해보자. 
> - 이런 경우, **파라미터로 전달되는 오브젝트의 클래스는 해당 인터페이스를 구현하기만 했다면, 어떤 것이든지 상관 x** 
>- 단지, 해당 인터페이스의 타입의 오브젝트라면 파라미터로 전달 가능, 파라미터로 제공받은 오브젝트는 인터페이스에 정의된 메소드만 이용한다면 그 오브젝트가 어떤 클래스로부터 만들어졌는지 신경쓰지 않아도 됨.

### 클래스 사이의 관계 VS 오브젝트 사이의 관계

 - **클래스 사이의 관계** : 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것. 
 - **오브젝트 사이의 관계** : 코드에선 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능.
<br>

## WHY? 
### 객체지향 프로그램에는 **다형성** 이라는 특징이 있기 때문!
### ✅ 다형성

> **하나의 타입에 여러 객체를 대입할 수 있는 성질**
> 
> 다형성을 활용하면 기능을 확장하거나, 객체를 변경해야할 때 타입 변경 없이 객체 주입만으로 수정이 일어나게 할 수 있다. 
>
> #### 다형성을 구현하는 방법 :
> - 오버로딩
> - 오버라이딩
> - 함수형 인터페이스
> 

## ✨ 결론 : 클라이언트와 같은 제3의 오브젝트가 UserDao 오브젝트가 사용할 ConnectionMaker 오브젝트를 전달해주도록 만들자 ! 
> **Fix: UserDao의 생성자** 
> 
>     public UserDao(ConnectionMaker connectionMaker){
>     	this.connectionMaker = connectionMaker;
>     }
> 

> **Feat: 클라이언트인 UserDaoTest** (UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존 관계를 설정하는 책임 담당)
> 
>     public class UserDaoTest {
>     	public static void main(String[] args) throws ClassNotFoundException, SQLException {
> 	    	   ConnectionMaker connectionMaker = new DConnectionMaker();
> 	    	   UserDao dao = new UserDao(connectionMaker);
> 	    	...
>     	}
>     }
### => 이제는 UserDao의 변경 없이도 자유롭게 N 사와 D사는 자신들을 위한 DB 접속 클래스를 만들어서 UserDao가 사용하게 할 수 있음🤗
<br>

## 👽 초난감 DAO 코드 개선해온 결과를 객체지향 기술의 여러 가지 이론 통해 설명해보자 

### ✅ 개방 폐쇄 원칙(OCP, Open-Closed Principle)
> 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중 하나
> ### **정의 : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다**
> - ex. 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방, 
> 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄.
> 
> 잘 설계된 객체지향 클래스 구조 = 개방 폐쇄 원칙을 아주 잘 지키고 있음.
> 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 개방 폐쇄 원칙을 따른다고 볼 수 있음.

<br>

### ✅ 객체지향 설계 원칙(SOLID)
>### **객체 지향의 특징을 잘 살릴 수 있는 설계의 특징**
> **원칙** : 어떤 상황에서든 100% 지켜져야 하는 절대적인 기준이라기보단, 예외는 있겠지만 대부분의 상황에 잘 들어맞는 **가이드라인**과 같은 것.
> ### 디자인 패턴 VS 객체지향 설계 원칙 
>>#### 디자인 패턴 : 특별한 상황에서 발생하는 문제에 대한 좀 더 구체적인 솔루션 
>>#### 객체지향 설계 원칙 : 좀 더 일반적인 상황에서 적용 가능한 설계 기준 
>당연한 일이지만, 객체지향 디자인 패턴은 대부분 객체지향 설계 원칙을 잘 지켜서 만들어져 있음.
>## 객체지향 설계 원칙(SOLID) 5가지
>- SRP(The Single Responsibility Principle): 단일 책임 원칙
>- OCP(The Open Closed Principle) : 개방 폐쇄 원칙
>- LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙
>- ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙
>- DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙

<br>

### ✅높은 응집도와 낮은 결합도(high coherence and low coupling)
> 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 소프트웨어 개발의 고전적인 원리로도 설명 가능.
>
> ## 응집도가 높다 
> = 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다
> = 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다 
> - #### 높은 응집도 : 클래스 레벨뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있음.
> ## 결합도가 낮다
> = 느슨하게 연결된 형태를 유지하는 것.
> 
> = **하나의 변경이 발생할 때, 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태**
> - 느슨한 연결 : **관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것.**  
> 
>-  if *결합도* ⬇️ => 변화 대응 속도 ⬆️, 구성 깔끔 ✨  
> >*결합도* *: 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도* 

<br>

### ✅ 전략 패턴(Strategy Pattern)
> `디자인 패턴의 꽃`이라고 불릴 만큼 다양하게 자주 사용되는 패턴
> 
> `개방 폐쇄 원칙의 실현`에도 가장 잘 들어맞는 패턴
> ### 정의 : 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 *알고리즘* 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴 
> > ####  여기서 *알고리즘* : 
> >- 거창한 수학적 알고리즘 x 
> >- 독립적인 책임으로 분리가 가능한 기능 o
>
>이를 대체 가능한 전략으로 보기 때문에 패턴이름 = `전략 패턴`
> ## 책에 있는 예시로 '전략 패턴' 설명해보자면, 
> #### UserDao : 전략 패턴의 컨텍스트
>컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리함.
> #### UserDaoTest와 같은 클라이언트의 역할 : 
> 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략(ConnectionMaker를 구현한 클래스, 예를 들어 DConnectionMaker)을 컨텍스트의 생성자 등을 통해 제공해주는 게 일반적

### 가장 최근에 만든 UserDao는 개방 폐쇄 원칙 잘 따르고 있고, 응집력이 높고 결합도는 낮으며, 전략 패턴을 적용👍

<br>

## 1.4 제어의 역전(IoC, Inversion of Control)
원래 **UserDaoTest**는 **UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것.**

그런데 지금은 또 다른 책임(어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능)까지 엉겁결에 떠맡았다😅
### 성격이 다른 책임이나 관심사 분리하는 것은 매우 주요한 작업, 그러니 이것도 아래와 같이 **분리**하자.

> - 관심사 1 : UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것.
> - 관심사 2 : 그렇게 만들어진 두 개의 오브젝트가 연결되서 사용될 수 있도록 관계를 맺어주는 것.

<br>

### 어떻게 분리? 

> ### 🙋 분리시킬 기능을 담당할 클래스를 만들자.
> **이 클래스의 역할 :** 
> 
 > - **객체의 생성 방법을 결정**하고 **그렇게 만들어진 오브젝트를 돌려주는 것**.
 > - 이런 일을 하는 오브젝트를 흔히 **✅ 팩토리(factory)** 라고 부름
 > -- 이는 디자인 패턴에서 말하는 특별한 문제를 해결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르니 혼동하지 말자.*
> - 단지, **오브젝트를 생성하는 쪽, 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용**하는 것.
> - **어떻게 만들지와 어떻게 사용할지는 분명 다른 관심**이다.


>**Feat: UserDao의 생성 책임을 맡은 팩토리 클래스** 
>
>     public class DaoFactory{
>		public UserDao userDao() {
>			ConnectionMaker connectionMaker = new DConnectionMaker();
>			UserDao userDao = new UserDao(connectionMaker);
>			return userDao;
>		}
>     } 

>**Fix: 팩토리를 사용하도록 수정한 UserDaoTest** 
>
>     public class UserDaoTest{
>		public static void main(String[] args) throws ClassNotFoundException, SQLException  {			
>			UserDao userDao = new DaoFactory().userDao();
>			...
>		}
>     } 
DaoFactory의 userDao 메소드 호출 -> DConnectionMaker를 사용해 DB 커넥션을 가져오도록 이미 설정된 UserDao 오브젝트를 돌려준다. 

UserDaoTest는 이제 UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 그만이다😊

<br>

### 🧐 분리된 오브젝트들의 역할과 관계를 분석해보자.
#### <실질적인 로직을 담당하는 컴포넌트>
- UserDao : 애플리케이션의 핵심적인 데이터 로직
- ConnectionMaker : 애플리케이션의 핵심적인 기술 로직
#### <애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도>
- DaoFactory : 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있음.

*설계도 : 간단히 어떤 오브젝트가 어떤 오브젝트를 사용하는지를 정의해놓은 코드*

#### 이렇게 오브젝트 팩토리를 사용했을 때 얻을 수 있는 장점 : 
- 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있음.

### if DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣으면 어떻게 될까?
- 🤦‍♀️ 문제 상황 : ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 메소드마다 반복됨

 - ✅ 해결 방법 : ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내자 => 제어의 역전이 일어난 상황!
>**Fix: 생성 오브젝트 코드 수정** 
>
>     public class DaoFactory{
>		 public UserDao userDao()  {			
>			  return new UserDao(connectionMaker());
>      }
>        public AccountDao accountDao() {
>           return new AccountDao(connectionMaker());
>      }
>        public MessageDao messageDao() {
>           return new MessageDao(connectionMaker());
>      }
>        public ConnectionMaker connectionMaker() {
>           return new DConnectionMaker(); 
>      }
<br>

## ✅ 제어의 역전(Inversion of Control)
간단히 말하자면, **프로그램의 제어 흐름 구조가 뒤바뀌는 것.**
### 일반적인 프로그램의 흐름 : 
> 1. 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 **결정** 
> 2. 결정한 오브젝트를 **생성** 
> 3. 만들어진 오브젝트에 있는 메소드르 **호출** 
> 4. 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업 반복

### 즉, 원래 프로그램의 제어 흐름은 모든 종류의 작업을 **사용하는 쪽에서 제어**하는 구조.
**제어의 역전**이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것.

> - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택 x, 생성 x
> - 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 x
> - 모든 제어 권한을 자신이 아닌 다른 대상에게 위임함!

=> 프로그램의 시작을 담당하는 **main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어짐**

<br>

## ✅ 제어의 역전 개념 적용 예시 1 : [서블릿](https://mangkyu.tistory.com/14)

> 서블릿 : 자바를 사용하여 웹을 만들기 위해 필요한 기술
> 
> 일반적 자바 프로그램 :
> > main() 메소드에서 시작해 개발자가 미리 정한 순서따라 오브젝트가 생성되고 실행됨. 
> 
> 그런데, 서블릿을 개발해서 서버에 배포할 순 있지만, 그 **실행을 개발자가 직접 제어할 수 있는 방법은 없음.**
> 
> 서블릿 안에 main() 메소드가 있어서 직접 실행시킬 수 있는 것도 아님.
> 
> 대신 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출함.
> 
> 이렇게 서블릿이나 JSP, EJB처럼 **컨테이너 안에서 동작하는 구조**는 간단한 방식이긴 하지만, 
> **제어의 역전 개념이 적용**되어 있다고 볼 수 있음.

<br>

## ✅ 제어의 역전 개념 적용 예시 2 : 디자인 패턴 - 템플릿 메소드 패턴

> ### 템플릿 메소드 패턴 
> ### 책에서 설명했던 코드로 얘기해보자면,
> 
> > 추상 UserDao를 상속한 서브클래스는 getConnection()을 구현함.
> > 
> > But, 이 메소드가 언제 어떻게 사용될지 자신은 모름.
> > 
> > 서브클래스에서 결정되는 게 아님.
> > 
> > 단지 이런 방식으로 DB 커넥션을 만든다는 기능만 구현해놓으면, **슈퍼클래스인 UserDao의 템플릿 메소드인 add(), get() 등에서 필요할 때 호출해서 사용**하는 것.
> ### 즉, 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는 제어의 역전 개념 발견 가능.
> ### 🤗 템플릿 메소드 = 제어의 역전이라는 개념 활용해 문제 해결하는 디자인 패턴

<br>

## ✅ 제어의 역전 개념 적용 예시 3 : 프레임워크
> ### 프레임워크 != 라이브러리
> ### 🧐 프레임워크 VS 라이브러리
> - **라이브러리** 사용하는 애플리케이션 **코드가 애플리케이션 흐름을 직접 제어.**
> - **프레임워크**는 애플리케이션 **코드가 프레임워크에 의해 사용됨.**
> 
> 	> 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다. 
> 
> 최근 툴킷, 엔진, 라이브러리 등도 유행을 따라서 무작정 프레임워크라고 부르기도 하는데 이는 잘못된 것.
> 
> ### 프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다.
> ### 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

#### 자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 바로 IoC(제어의 역전)를 적용하는 작업이었다고 볼 수 있음.
<br>

**IoC를 적용**하면, **설계 깔끔, 유연성 증가, 확장성 Good** => 필요할 때면 IoC 스타일의 설계와 코드를 만들어 사용하자!

#### IoC에서는 프레임워크 또는 컨테이너와 같이 **애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요**

DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다. 

단순한 적용이라면 DaoFactory와 같이 IoC 제어권을 가진 오브젝트를 분리해서 만드는 방법이면 충분하겠지만, **IoC를 애플리케이션 전반에 걸쳐 본격적으로 적용하려면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 훨씬 유리**

### 🌱 스프링 : IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크
<br>

## 1.5 스프링의 IoC
### 스프링의 핵심을 담당하는 건, **빈 팩토리** 또는 **애플리케이션 컨텍스트**라고 불리는 것
***빈 팩토리bean factory)를 좀 더 확장한 게 애플리케이션 컨텍스트(application context)***
*앞으로 이 두 용어 같이 사용할 건데 두 가지가 동일하다고 생각하면 됨.*
>  - '**빈 팩토리**' 라고 말할 때 : 주로 빈의 생성과 제어의 관점에서 이야기하는 것.
>  
>  - '**애플리케이션 컨텍스트**' 라고 말할 때 : 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것.

<br>

### ⚙️ 스프링 프레임워크의 빈 팩토리 또는 애플리케이션 컨텍스트가 IoC 방식의 기능을 제공할 때 사용할 설정정보 만드는 애노테이션

> #### ✅ @Configuration : 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
> #### ✅ @Bean : 오브젝트 생성을 담당하는 IoC용 메소드라는 표시

> #### Fix: 스프링 빈 팩토리가 사용할 설정정보 담도록 DaoFactory 클래스 수정
> 
>	    @Configuration
>	    public class DaoFactory{
>			@Bean
>			public UserDao userDao() {
>				return new UserDao(connectionMaker());
>			}
>			@Bean
>			public ConnectionMaker connectionMaker(){
>				return new DConnectionMaker();
>			}
>		}
>
><br>

>  #### @Configuration이 붙은 자바 코드를 설정정보로 사용하려면? 
>  - AnnotationConfigApplicationContext를 이용
>  - 애플리케이션 컨텍스트 만들 때 생성자 파라미터로 DaoFactory 클래스 넣어줌
>  - 준비된 ApplicationContext의 getBean()이라는 메소드 이용해 UserDao의 오브젝트 가져올 수 있음.
> 
> <br>

> ####  Fix : 애플리케이션 컨텍스트를 적용한 UserDaoTest 
> > >
>	    public class UserDaoTest{
>			public static void main(String[] args) throws ClassNotFoundException, SQLException {
>				ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
>             UserDao dao = context.getBean("userDao", UserDao.class);
>			}
>		}
>   ### 🧐 `getBean("@Bean 붙인 메소드이름", 클래스);`
>   >  - 빈을 가져온다 = 메소드 호출해서 그 결과를 가져온다
> >- getBean은 기본적으로 Object 타입으로 리턴 => 매번 리턴되는 오브젝트에 다시 캐스팅해줘야 하는 부담 존재 => 자바 5 이상의 **제네릭(generic) 메소드 방식을 사용해 getBean()의 두 번째 파라미터에 리턴타입을 주면,** 지저분한 캐스팅 코드를 사용하지 않아도 됨.

<br>

## 👍 DaoFactory를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점
### 1. 클라이언트는 구체적인 팩토리 클래스를 알 필요 X

### 2. 종합 IoC 서비스를 제공
> #### 애플리케이션 컨텍스트의 역할 :
>  - **오브젝트 생성, 다른 오브젝트와의 관계 설정**만이 전부가 아님.
> 	
> 	 - **오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등** 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공함.
> 	
> 	 - **빈이 사용할 수 있는 기반기술 서비스 or 외부 시스템과의 연동 등**을 컨테이너 차원에서 제공해주기도 함

	
### 3. 빈을 검색하는 다양한 방법 제공
> ex. 애플리케이션 컨텍스트의 getBean() 메소드
> 
> ➕ 타입만으로 빈 검색 or 특별한 애노테이션 설정되어있는 빈 찾을 수도 있음.

<br>

## 🌱 스프링 IoC 용어 정리
### ✅ 빈(bean)
> **빈** 또는 **빈 오브젝트** 
> = **스프링이 IoC 방식으로 관리하는 오브젝트** 
> = also called **관리되는 오브젝트**(managed object) 
> 
> 👽 주의할 점 : 스프링 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아님!
> 
> **스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 `빈` 이라고 부름.**


### ✅ 빈 팩토리(bean factory)
> #### 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킴.
> **빈을 등록, 생성, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능 담당**
> 
> 보통은 이 빈 팩토리를 바로 사용하지 않고, 이를 확장한 애플리케이션 컨텍스트를 이용함.
> 
> `BeanFactory` 라고 붙여쓰면 **빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름**이 됨.  
> - 이 인터페이스에 `getBean()` 과 같은 메소드가 정의되어 있음.
> 
### ✅ 애플리케이션 컨텍스트(application context)
> ####  빈 팩토리를 확장한 IoC 컨테이너
> **빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일**함. 
> ➕ **스프링이 제공하는 각종 부가 서비스를 추가로 제공** 
> 
> **스프링에서는 애플리케이션 컨텍스트**라는 용어를 빈 팩토리보다 **더 많이 사용**함. 
> 
> `ApplicationContext`라고 적으면 **애플리케이션 컨택스트가 구현해야 하는 기본 인터페이스를 가리키는 것**이기도 함.
> 
> `ApplicationContext`는 `BeanFactory`를 상속.
### ✅ 설정정보/설정 메타정보(configuration metadata)
> #### 스프링의 설정정보 : 
> - **애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보**
> 
> configuration = 구성정보 내지는 형상정보라는 의미
> 
> 실제로 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 **IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용됨.**
> 
> 애플리케이션의 형상 정보, 애플리케이션의 전체 그림이 그려진 청사진(blueprints) 라고도 부름.

### ✅ 컨테이너(container) 또는 IoC 컨테이너

> #### IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
> 
> - IoC 컨테이너 : 주로 빈 팩토리의 관점에서 이야기하는 것. 
> - 컨테이너 또는 스프링 컨테이너 : 애플리케이션 컨텍스트를 가리킴
> 
> **컨테이너 말 자체**가 **IoC의 개념을 담고 있음.**
> 
> 컨테이너라는 말은 **애플리케이션 컨텍스트보다 추상적인 표현**이기도 함.
> 
> 애플리케이션 컨텍스트는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데, 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용함. 이를 통틀어서 **스프링 컨테이너**라고 부를 수 있음.
> 
> 예를 들어, `스프링에 빈을 등록하고` 라는 식으로 말하는 경우에 **스프링**이라는 말은 **스프링 컨테이너** 또는 **애플리케이션 컨텍스트**를 가리키는 말이다.
> 
> ### 결론 : 
> 컨테이너
> 
> = IoC 컨테이너
> 
> = 빈 팩토리
> 
> = 애플리케이션 컨텍스트
> 
> = 스프링 컨테이너
> 
> = `스프링에 빈을 등록한다`는 표현 속에서의 `스프링`
> 
> 마성의 단어 컨테이너 .... 😎
 
### ✅ 스프링 프레임워크
> #### IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 **스프링이 제공하는 모든 기능을 통틀어 말할 때** 주로 사용함.
> 그냥 🌱 **스프링**이라고 줄여서 말하기도 함.

<br>

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
### 오브젝트의 동일성(identity)과 동등성(equality)
👽 자바에서 두 개의 오브젝트가 같은가라는 말은 주의해서 써야 한다.

**두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트**와
**동일한 정보를 담고 있는(equivalent) 오브젝트**는 **다르다**.

### ✅ 동일성은 == 연산자, 동등성은 equals() 메소드 이용해 비교함.
- **두 개의 오브젝트가 동일**하다면 
	> **사실은 하나의 오브젝트만 존재**하는 것이고, **두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐.**

- **두 개의 오브젝트가 동일하지는 않지만 동등한 경우,** 	
	> **두 개의 각기 다른 오브젝트가 메모리상 존재**하는 것인데, 오브젝트의 **동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단되는 것일 뿐**이다.

물론 동일한 오브젝트는 동등하기도 할 것이지만, 그 반대는 항상 참이 아니다.

<br>

## 🧐 앞에서 만들었던 오브젝트 팩토리와 스프링의 애플리케이션 컨텍스트의 동작방식의 차이
**스프링**은 여러 번에 걸쳐 빈을 요청하더라도 **매번 동일한 오브젝트를 돌려준다.**
> 단순하게 getBean() 을 실행할 때마다 userDao() 메소드를 호출하고, 매번 new에 의해 새로운 UserDao가 만들어지지 않는다는 뜻.
> 
### 왜 그럴까?

### ✅ 애플리케이션 컨텍스트는 
- 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 **`IoC 컨테이너.`**

- 동시에, 싱글톤을 저장하고 관리하는 **`싱글톤 레지스트리(singleton registry)`** 이기도 함.

🌱 스프링은 기본적으로 별다른 설정하지 않으면, 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

👽 *여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.*

<br>

## 왜 스프링은 싱글톤으로 빈을 만들까?
 ### 🙋 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문
  > #### 스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경
  >- 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경 
  >
  >- 하나의 요청 처리 위해 데이터 액세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등 다양한 기능 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 대부분 
  >
   >- 비즈니스 로직도 복잡 😅 

   >### 그래서...
> 엔터프라이즈 분야에선 `서비스 오브젝트`라는 개념을 일찍부터 사용해왔음. 
>
>`서블릿`은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있음.
>
>스펙에서 강제하진 않지만, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작함.
>
>서블릿 클래스당 하나의 오브젝트만 만들어주고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용함.
> 

> ### 이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리!
> ### 따라서, 서버환경에서는 ✨서비스 싱글톤✨의 사용이 권장된다.
> 
> 하지만, **디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점 존재**
> 
> 심지어 이런 싱글톤 패턴을 피해야 할 패턴이라는 의미로 안티패턴(anti pattern) 이라고 부르는 사람도 있음.

<br>

### 📚 디자인 패턴 - 싱글톤 패턴(Singleton Pattern)

> 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴
> 
> 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근 가능
> 
> 단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용함
<br>

## 😥 자바에서 싱글톤 패턴의 한계
>1. private 생성자를 갖고 있기 때문에 상속 불가
>		> 객체지향의 장점인 상속과 이를 이용한 다형성을 적용 불가
>2. 테스트하기가 힘듦
>
>3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못함
>
>4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못함
> 

> 스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다.
> 
> 하지만, 자바의 기본적인 싱글톤 패턴 구현 방식은 여러 단점 존재 
> 
> 그리하여 **스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공** 🤗
> 
> 그것이 바로 **싱글톤 레지스트리(singleton registry)**


<br>

## ✅ 싱글톤 레지스트리(singleton registry)

> ### 장점 : 
> - **스태틱 메소드와 private 생성자를 활용하게 해줌**
>  
> 	>- 평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해 생성, 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리하게 할 수 있음.
> 	>
> 	>- 오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문!
> - **싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자 가질 수 있음.**
> - 싱글톤으로 사용되어야 하는 환경이 아니라면 **간단히 오브젝트를 생성해서 사용할 수도 있음.**
> 	>  테스트 환경에서 자유롭게 오브젝트를 만들 수 있고, 테스트를 위한 Mock 오브젝트로 대체하는 것도 간단함.
> - **생성자 파라미터를 이용**해서 **사용할 오브젝트를 넣어주게 할 수도 있음.**
> 
> ####  👍 가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴(싱글톤 패턴 제외) 등을 적용하는 데 아무런 제약 없다는 점이다.
>  스프링은 **IoC 컨테이너**일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해주는 **싱글톤 레지스트리**라는 점을 기억해두자
> 
> 스프링이 **빈을 싱글톤으로 만드는 것**은 결국 **오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할**이다.

<br>

## 👽 싱글톤으로 만들어지기 때문에 주의해야 할 점

> **싱글톤**은 **멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용 가능** 
> => 🧐 **상태 관리**에 주의 기울여야 함. 
> 
> #### 기본적으로 **싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우** : 
> > 상태정보를 내부에 갖고 있지 않은 **무상태(stateless) 방식**으로 만들어져야 함.
> 
> 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험함. 
> > 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문 
> 
> 따라서, 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 X
> 
> 근데 읽기 전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 건 아무런 문제 없음.
> 
> 	- 물론 단순한 읽기전용 값이라면 `static final` 이나 `final` 로 선언하는 편이 나음

<br>
 
### 🧐 상태가 없는 방식(stateless)으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까?
> #### 🙋‍♀️ 파라미터와 로컬 변수, 리턴 값 등을 이용
> - **메소드 파라미터**나, 메소드 안에서 생성되는 **로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에** 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없음

<br>

### 스프링 빈의 스코드(scope)
> #### 스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위
> **스프링 빈의 기본 스코프 : 싱글톤**
> 
> 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지됨
> 
> 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 가짐.
> 
> 경우에 따라서 싱글톤 외의 스코프도 가질 수 있음. 
> > 대표적으로 **프로토타입(prototype) 스코프**가 있음.
>> - 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어줌. 

<br>

## 1.7 의존 관계 주입(DI)
IoC는 소프트웨어에서 자주 발견할 수 있는 일반적인 개념

객체를 생성하고 관계를 맺어주는 등의 작업 담당하는 기능을 일반화한 것 => 스프링의 IoC 컨테이너
### IoC 용어 
> IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어임.
> 
> => 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명 x
> 
> => 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 **의존관계 주입(Dependency Injection)** 이라는, 좀 더 의도가 명확히 드러나는 이름 사용하기 시작
> 
> **스프링 IoC 기능의 대표적인 동작원리**는 주로 **의존관계 주입**이라고 불림


> 초기엔 주로 IoC 컨테이너 라고 불리던 **스프링** 
> 
> ✅ 지금은 **의존관계 주입 컨테이너** 또는 영문약자를 써서 **DI 컨테이너**라고 더 많이 불리고 있음

<br>

#### 📃 Dependency Injection 번역
- **의존관계 주입** (이 책에선 이게 가장 적절하다고 봄) ✅

- **의존성 주입** (가장 많이 사용 => 근데 의존성이라는 말은 DI의 의미가 무엇인지 잘 드러내주지 못함)

- **의존(종속) 오브젝트 주입** (DI 가 일어나는 방법에 초점 맞춘 것 => 엄밀히 말해 오브젝트는 다른 오브젝트에 주입할 수 있는 게 x 그저 오브젝트의 레퍼런스가 전달될 뿐임) 

- **의존관계 설정** (의도를 강하게 드러내는 이 용어도 나쁘지 않다고 봄)

<br>

## ✅ 의존관계란?
> 항상 **방향성** 부여해줘야 함.
> 
> 즉, **누가 누구에게 의존하는 관계에 있다**는 식이어야 함.
> 
> A 클래스 --------> B 클래스

>## 의존하고 있다 : 
>
> 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻
> 
> B의 기능이 추가 or 변경 or 형식이 바뀌거나 하면 그 영향이 A로 전달된다.
> 
>
> ✅ 대표 예시 : **A가 B를 사용**하는 경우, 
> > **A에서 B에 정의된 메소드를 호출해서 사용하는 경우**
> >
>> =>  '**사용에 대한 의존관계가 있다**' 고 말할 수 있음.
>
>if B에 새로운 메소드 추가되거나 기존 메소드 형식 바뀌면, A도 그에 따라 수정되거나 추가돼야 할 것. 
>
>또는 B의 형식이 그대로지만 기능이 내부적으로 변경되면, 결과적으로 A의 기능이 수행되는 데도 영향 미칠 수 있음.
>
>이렇게 **사용의 관계에 있는 경우에 A와 B는 의존관계가 있다고 말할 수 있음.**
>
> ✅ **방향성이 있어 A가 B에 의존하고 있지만, 반대로 B는 A에 의존하지 X**
> 
> >의존하지 않는다 = B는 A의 변화에 영향 받지 않는다

<br>

### ✅ 런타임 의존관계
> #### 런타임 시에 오브젝트 사이에서 만들어지는 의존관계
> 
> 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있음.

<br>

### ✅ 의존 오브젝트(dependent object)

> 프로그램이 시작되고 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 
> 
> 즉 **실제 사용대상인 오브젝트**

<br>

### ✅ 의존관계 주입(DI)
> 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업

>#### **의존관계 주입**은 다음과 같은 **세 가지 조건**을 충족하는 작업을 말함.
> ✅ **클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 x**
> 	>	그러기 위해서는 인터페이스에만 의존하고 있어야 함.
>
> ✅ **런타임 시점의 의존관계**는 **컨테이너나 팩토리 같은 ✨제3의 존재✨가 결정**
> > 제3의 존재 : 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트 
> >
> > ex. 전략 패턴에 등장하는 클라이언트, 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등 
> 
> ✅ **의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어짐.** 

<br>

### ✅ DI 컨테이너
> #### **의존관계 주입을 담당하는 컨테이너**
> 
> 보통 DI는 그 근간이 되는 개념인 IoC와 함께 사용해서 **IoC/DI 컨테이너**라는 식으로 함께 사용하기도 함.
> 
> DI는 **자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다**는 점에서 **IoC의 개념에 잘 들어맞음.**
> 
> 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점 맞춰져 있음.
> 
> 🌱 **스프링**
> 
> = IoC 컨테이너 
> 
> = DI 컨테이너 
> 
> = DI 프레임워크 라고 부름 

<br>

## 🧐 의존관계 주입 VS 의존관계 검색

>### ✅ 의존관계 주입(DI)
>**주입 = 외부에서 내부로 무엇인가를 넘겨줘야 하는 것**
>
>자바에서 오브젝트에 무엇인가를 넣어준다는 개념은 **메소드를 실행하면서 파라미터로 오브젝트의 레퍼런스를 전달**해주는 방법뿐.
>
>가장 손쉽게 사용할 수 있는 **파라미터 전달이 가능한 메소드**는 바로 **생성자.**
 
> 스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 건 x
> 
> 코드에서는 구체적인 클래스에 의존하지 x, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주입과 비슷하지만, 
> 
> 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 **스스로 검색을 이용**하기 때문에 **의존관계 검색(dependency lookup)** 이라고 불리는 것도 있음.

>### ✅ 의존관계 검색(DL)
> 의존관계 검색은 **자신이 필요로 하는 의존 오브젝트를 능동적으로 찾음** 
> 
> 물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하진 x
> > 그러면 IoC라고 할 수 없기 때문
> 
>  **런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만**, **이를 가져올 때**는 메소드와 생성자를 통한 주입 대신 **스스로 컨테이너에게 요청하는 방법 사용**
> >스프링의 IoC 컨테이너인 애플리케이션 컨텍스트의 `getBean()` 이라는 메소드 사용
> 
> ## 
> 
> ### 🧐 둘 중 어떤 것이 더 나을까? 
> 🙋‍♀️ **의존관계 주입** 쪽이 훨씬 단순 & 깔끔
> > 그런데 의존관계 검색 방식을 사용해야 할 때가 있다. 
> > 
> > ex. 테스트 코드
> 
> <br>
> 
> ### ✅ 적용 시 발견할 수 있는 중요한 차이점
> - **의존관계 검색 방식**에서는 **검색하는 오브젝트(UserDao)는 자신이 스프링의 빈일 필요가 없다**는 점.
> 
> - 반면에, **의존관계 주입**에서는 UserDao도 **반드시 컨테이너가 만드는 빈 오브젝트여야 한다.**

<br>

### 💬 "DI 받는다"
> 단지 외부에서 파라미터로 오브젝트를 넘겨줬다고 해서, 즉 주입해줬다고 해서 다 DI가 아니라는 점을 주의 👽
>
>**주입받는 메소드 파라미터가 이미 특정 클래스 타입으로 고정되어 있다면, DI가 일어날 수 X**
>
>✅ **DI에서 말하는 주입** = 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 **인터페이스 타입의 파라미터를 통해 이뤄져야 함**.
>
> 이 책에서는 DI 원리를 지키며 외부에서 오브젝트를 제공받는 방법을 단순히 '주입받는다'라고 하는 대신 'DI 받는다'라고 표현할 것임.
> 
> 단순한 오브젝트 주입이 아니라, DI 개념을 따르는 주입임을 강조하는 것임.

<br>

### 👍 DI 기술의 장점
> 앞에서 살펴봤던 오브젝트 팩토리 = 바로 이 DI 방식을 구현한 것.
> 
> 객체지향 설계와 프로그래밍의 원칙을 따랐을 때 얻을 수 있는 장점이 그대로 DI 기술에도 적용될 것.
> ## 
> **장점 :** 
> 1. 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않음
> 2. 인터페이스를 통해 결합도가 낮은 코드
> 3. 다른 책임 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향 받지 x
> 4. 변경 통한 다양한 확장 방법에 자유로움

<br>

### ✅ DI 적용 예시 1 : 
#### DB 연결 기능있는 클래스 만들 때, DI 방식 적용해서 만들자.
>Feat: 로컬에서 개발용 ConnectionMaker 생성 코드
>
>	    @Bean
>	    public ConnectionMaker connectionMaker() {
>	    	return new LocalDBConnectionMaker();
>	    }
>
서버에 배포할 때 코드 한 줄만 수정하면 됨🤗
>Fix: 서버 운영용으로 ConnectionMaker 수정 
>
>	    @Bean
>	    public ConnectionMaker connectionMaker() {
>	    	return new ProductionDBConnectionMaker();
>	    }

<br>

### ✅ DI 적용 예시 2 : 
#### 새로운 기능을 추가하고 싶을 때 DI 방식을 적용해서 만드는 방법
관련 내용 및 코드 p.122 ~ p.125
- 기존에 있는 인터페이스를 implements 하여 새로운 기능이 관련한 클래스 생성
- 의존관계가 추가된 DI 설정용 클래스 생성
- 새로운 기능 테스트하는 클래스 생성 (테스트 시 `getBean()` 메소드 이용)
<br>

### ✅ 의존관계 주입(DI) 방법 3가지

> #### 1. 생성자 사용한 주입
>- **생성자**가 수정자 메소드보다 **나은 점** :
> 
>   - **한 번에 여러 개의 파라미터를 받을 수 있다** 
>  
>   - 하지만, 파라미터의 개수 많아지고 비슷한 타입이 여러 개라면 실수하기 쉬움
> 

> #### 2. 수정자 메소드를 이용한 주입 (가장 많이 사용해왔음)
> - 수정자 메소드는 항상 **set**으로 시작함.
>
>- **수정자 메소드의 핵심 기능** : 
>	- 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것.
>
>	- 입력 값에 대한 검증이나 그 밖의 작업 수행할 수도 있음.

>#### 3. 일반 메소드를 이용한 주입
>- set 시작 싫고 한 번에 한 개의 파라미터만 가질 수 있다는 제약도 싫으면 **여러 개의 파라미터를 갖는 일반 메소드**를 DI용으로 사용할 수 있음.
>
>- 임의의 초기화 메소드를 이용하는 DI는 적절한 개수의 파라미터를 가진 여러 개의 초기화 메소드를 만들 수도 있기 때문에 한 번에 모든 필요한 파라미터를 다 받아야 하는 생성자보다 낫다.

<br>

## 1.8 XML을 이용한 설정
스프링은 DaoFactory와 같은 자바 클래스를 이용하는 것 외에도, 

다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있는데, 

가장 대표적인 것이 **XML**이다.

### ✅ XML 이란
>단순한 텍스트 파일
>
>다루기 쉬움, 쉽게 이해 가능, 컴파일과 같은 별도의 빌드 작업 x 
>
>환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영 가능
>
>스키마나 DTD를 이용해 정해진 포맷을 따라 작성되었는지 손쉽게 확인 가능

<br>

#### 하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보 3가지
1. 빈의 이름 
	> @Bean 메소드 이름이 빈의 이름. 
	>
	> 이 이름은 `getBean()`에서 사용됨
	
2. 빈의 클래스
	>
	> 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의함.
	
3. 빈의 의존 오브젝트
	>
	> 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어줌. 
	>
	> 의존 오브젝트도 하나의 빈이므로 이름이 있을 것이고, 그 이름에 해당하는 메소드를 호출해 의존 오브젝트를 가져옴. 
	>
	> 의존 오브젝트는 하나 이상일 수도 있음.

<br>

### ✅ 클래스 설정과 XML 설정의 대응항목
|  |자바 코드 설정정보  |XML 설정정보 |
|--|--|--|
|빈 설정파일  |@Configuration  |\<beans>  |
|빈의 이름  |@Bean methodName()  |<bean id="methodName"  |
|빈의 클래스  |return new BeanClass();  |class="a.b.c... BeanClass"  |

👽 주의 : \<bean> 태그의 class 애트리뷰트에 지정하는 것은 자바 메소드에서 오브젝트를 만들 때 사용하는 클래스 이름

<br>

### ✅ \<property> 태그 
> name, ref 두 개의 애트리뷰트 가짐.
> 
> - name : 프로퍼티의 이름(이 프로퍼티의 이름으로 수정자 메소드 알 수 있음)
> 
> - ref : 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름


>		userDao.setConnectionMaker(connectionMaker());
> 
> XML에서는 아래와 같이 작성할 수 있다.
> 
>		<property name="connectionMaker" ref="connectionMaker" />

<br>

### 🧐 프로퍼티 값 주입
수정자 메소드에는 다른 빈이나 오브젝트뿐 아니라, **스트링 같은 단순 값**을 넣어줄 수도 있음.

**텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것**

= 스프링에서는 '**값을 주입한다**'고 말한다.

이것은 성격은 다르지만 **일종의 DI**라고 볼 수 있음.
> 사용할 오브젝트 자체를 바꾸지는 않지만 오브젝트의 특성은 외부에서 변경할 수 있기 때문

**\<property>** 에서 ref 대신 **value** 사용한다.
> 예시 1) `<property name="driverClass" value="com.mysql.jdbc.Driver"/>`
> 
> 예시 2) `<property name="username" value="spring"/>`