## 1. 오브젝트와 의존관계
 

  

    public class UserDao{
	    public void add(User user) throws ClassNotFoundException,SQLException{
			// 디비 연결 + 회원 저장
		}
		public User get(String id)throws ClassNotFoundException,SQLException{
			// 디비 연결 + 회원 조회
		}
    }

#### 이 코드가 초난감한 이유는? : 관심사의 분리가 이루어지지 않음 

#### 1. DAO 관심사의 분리
UserDao의 관심사를 3가지로 구분하면
1. 디비 연결
2.  sql 실행
3. 공유 리소스 시스템에 리턴

이를 만족하기 위해서 먼저 **중복**을 제거하자
중복된 디비 연결 코드 -> getConnection() 메소드로 추출
더 나아가 확장을 하기위해 **상속**을 하자 -> 추상클래스/추상메소드 활용
더 나아가 분리를 위해 독립적 클래스로 만들자
--> 클래스와 코드에 종속되는 문제발생
**인터페이스**를 도입하자 -> 어떤 일을 하는 기능만 정의해두면 클래스들이 알아서 구현하는 모습! -> UserDao클래스가 인터페이스 외 클래스와는 관계를 갖게 하지 말자!

#### 2. 객체지향 설계 원칙 SOLID
##### 객체지향의 특징을 잘 살릴 수 있는 5가지 설계의 특징

 1. SRP : 단일 책임 원칙
 2. OCP : 개방 폐쇄 원칙(높은 응집도와 낮은 결합도)
 3. LSP : 리스코프 치환 원칙
 4. ISP : 인터페이스 분리 원칙
 5. DIP : 의존관계 역전 원칙

#### 3. 제어의 역전(IoC)

> **제어의 역전**이란? : 프로그램의 제어 흐름 구조가 뒤바뀌는 것

 - 일반적 프로그램 흐름 
모든 오브젝트가 자신이 사용할 클래스 결정 + 관장 + 제어
 - 제어의 역전에서 나타나는 프로그램 흐름
 오브젝트는 모든 제어 권한을 다른 대상에게 위임 --> 제어 권한이 있는 **특별한 오브젝트**가 제어함

> DaoFactory가 클래스 구현 권한 받음 -> UserDao는 수동적인 존재로 변화

**용어정리**

 - 빈 : 스프링이 IoC방식으로 관리하는 오브젝트. 즉 관리되는 오브젝트
 - 빈 팩토리 : Ioc를 담담하는 핵심 컨테이너. 빈 관리 기능
 - 애플리케이션 컨텍스트 : 빈 팩토리를 확장한 컨테이너. 빈 팩토리 상속
 - 설정정보/설정 메타정보 : IoC적용을 위한 메타정보
 - 컨테이너 : IoC 방식으로 빈을 관리하는 대상을 뜻함
 
 #### 4. 싱글톤 레지스트리
 먼저, 오브젝트의 동일성 vs 동등성
 
 - 동등성 : == 비교. 하나의 오브젝트, 두 개의 레퍼런스 변수
 - 동일성 : equals() 비교. 각기 다른 오브젝트가 메모리에 존재
 
 스프링의 애플리케이션 컨텍스트에서 오브젝트를 가져와보자.
 

    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao1 = context.getBean("userDao", UserDao.class);
    UserDao dao2 = context.getBean("userDao", UserDao.class);
    System.out.println(dao1);
    System.out.println(dao2);
    // 출력 결과가 같다!
  알 수 있는건, 스프링은 여러 번 빈을 요청하더라도 매번 동일한 오브젝트를 반환한다는 것이다. 왜일까?

#### 싱글톤 패턴

> 애플리케이션 안에서 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 원리. 멀티스레드 활용

싱글톤 패턴은 디자인 패턴 중의 하나이다. 하지만 몇 가지 한계점이 존재한다.

 1. private 생성자로 인한 상속 불가의 문제
 2. 테스트의 어려움
 3. 서버환경에서 하나의 싱글톤 보장이 힘든 문제
 4. 전역 상태를 만드는 문제

그런데, 스프링은 서버환경에서 싱글톤 상태를 적극 지지한다. 그렇다면 어떻게 싱글톤 패턴의 한계를 극복할 수 있을까?

#### 싱글톤 레지스트리

> 싱글톤 패턴의 한계를 보완하는 기능. 스태틱과 private사용할 필요 없이 일반 자바 클래스를 싱글톤으로 활용케한다.

싱글톤은 주로 멀티스레드 환경에서 접근이 이루어지므로 무상태 방식을 유지해야한다. 
스프링 빈의 기본 스코프(빈이 적용되는 범위)는 싱글톤이다.

#### 5. 의존관계 주입(DI)

> **의존관계** : **방향성**이 존재하는 관계. A클래스가 B클래스의 변화에 영향을 받는다는 것은 A클래스가 B클래스에게 의존하고 있음을 뜻한다.

**의존관계 주입**

 1. 런타임 시점의 의존관계는 들어나지 않는다. 즉, 인터페이스에만 의존해야한다.
 2. 의존관계는 **제 3자가 결정**한다.(컨테이너나 팩토리)
 3. 의존관계는 레퍼런스를 외부에서 오브젝트에게 주입해주어서 만들어진다.

메소드를 활용해서 컨테이너가 클래스에게 주입해준다.

    public class UserDao{
	    private ConnectionMaker connectionMaker;
	    public UserDao(ConnectionMaker connectionMaker){
		    this.connetionMaker = connectionMaker;
	    }
    }

주의해야할 점은, 의존관계 주입 시 주입 받는 클래스는 반드시 컨테이너가 만드는 빈 오브젝트 이어야 한다.

**의존관계 주입하는 방법**

 1. 생성자 이용
 2. 수정자 메소드(setter)이용(스프링이 전통적으로 가장 많이 사용하는 방식)
 3. 일반 메소드 이용

수정자 메소드(setter)을 이용하는 방식

    public class UserDao{
	    private ConnectionMaker connectionMaker;
	    public void setConnetcionMaker(ConnectionMaker connectionMaker){
		    this.connectionMaker = connectionMaker; // 인스턴스 변수에 저장
	    }
    }


#### 6. XML 설정

> XML파일을 이용해서 간단하게 의존관계 설정정보를 구축할 수 있다.

@Bean을 통해 얻을 수 있는 빈의 정보
 1. 빈의 이름 : @Bean 메소드 이름이 빈의 이름. getBean()으로 얻어옴
 2. 빈의 클래스 : 빈 오브젝트를 어떤 클래스를 이용해서 만들지 정의
 3. 빈의 의존 오브젝트 : 빈의 생성자나 수정자를 통해 의존 오브젝트를 주입

XML에서 사용하려면

 1. @Configuration -> < beans >
 2. @Bean methodName() -> <bean id="methodName"
 3. return new BeanClass(); -> class="a,b,c... BeanClass">

#### 7. 정리

 1. 관심사의 분리를 지키기위해 두 개의 클래스로 나누고
 2. 한 클래스를 인터페이스로 변경하여 인터페이스를 통해 클래스가 접근하도록 만들었다.
 3. 이를 통해 자신의 책임 자체가 변경되는 경우에는 불필요한 변화를 방지하고 외부 기능을 자유롭게 확장하고 변경하게 만들었다.
 4. 즉, 높은 응집도와 낮은 결합도를 만들었다.
 5. 별도의 오브젝트 팩토리에게 오브젝트 작업을 위임하면서 제어의 역전을 구현하였다.
 6. 스프링은 싱글톤 패턴의 한계를 극복한 싱글톤 레지스트리를 이용한다.
 7.  인터페이스를 통해 느슨한 의존관계를 만들고 제 3자에게 의존관계를 결정하게 하면서 의존관계 주입을 했다.
 8. XML파일을 통해 의존관계 설정 정보를 만들었다.

