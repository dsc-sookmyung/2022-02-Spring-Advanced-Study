## 6. AOP

> AOP는 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법이다.

### 5. 스프링 AOP
#### 1. 자동 프록시 생성
한 가지 해결해야할 과제는 ProxyFactoryBeam 빈 설정정보를 추가하는 부분이다. 

문제가 되는 이유는? : 설정을 매번 복사해서 붙이는 작업이 반복되는 것!

#### 빈 후처리기를 이용한 자동 프록시 생성기

>빈 후처리기는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.

스프링 컨테이너는 변하지 않는 핵심적인 부분외에는 대부분 확장할 수 있도록 확장 포인트를 제공하는데, 이를 활용해서 위의 문제를 해결해보자

빈 후처리기는 BeanPostProcessor 인터페이스를 구현해서 만들어진다.

DefaultAdvisorAutoProxyCreator은 어드바이저를 이용한 자동 프록시 생성기이다. 
1. 빈 후처리기 자체를 빈으로 등록하고
2. 빈 오브젝트가 생성될 때마다 스프링이 후처리 작업을 요청한다.
3. 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록이 가능하다. 

--> 위의 과정이 자동 프록시 생성 빈 후처리기 이다. 
![빈 후처리기를 이용한 프록시 자동생성](https://leejaedoo.github.io/assets/img/%EB%B9%88%ED%9B%84%EC%B2%98%EB%A6%AC%EA%B8%B0.jpeg)

1. 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
2. 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인하고
3. 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게한다.
4. 이렇게 만들어진 프록시에 어드바이저를 연결한다.
5. 프록시 생성이 완료되면 프록시 오브젝트를 컨테이너에게 돌려준다.
6. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

--> 빈 후처리기를 사용하면 일일이 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.

#### 확장된 포인트컷
위의 2번 과정에서 이상한 점이 있다. 

바로 포인트컷이 등록된 빈 중에서 어떤 빈을 프록시에 적용할지를 선택한다고 설명해 놓은 것!

실제로 포인트컷은 어떤 메소드에 부가기능을 적용할지를 선정하는 역할과 더불어 위의 역할도 수행한다.

    public  interface  Pointcut  {  
	    ClassFilter  getClassFilter();  
	    MethodMatcher  getMethodMatcher();  
    }
PointCut 선정 기능을 모두 적용하면 
1. 먼저 프록시를 적용할 클래스인지 판단하고(클래스 필터 기능)
2. 적용 대상 클래스일 때 어드바이스를 적용할 메소드인지 확인한다.

* 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용했다고 해도 부가기능은 전혀 제공되지 않는다.

#### 2. DefaultAdvisorAutoProxyCreator의 적용

#### 클래스 필터를 적용한 포인트컷 작성
메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만들자

    public  class  NameMatchClassMethodPointcut  extends  NameMatchMethodPointcut {
	    public void setMappedClassName(String mappedClassName) {
		    this.setClassFilter(new SimpleClassFilter(mappedClassName));
	    } // 필터 생성
	    ...
    }
* xml파일 설정을 통해 ServiceImpl로 끝나는 클래스, upgrade로 시작하는 메소드를 선정해주도록 설정한다.
* 어드바이스와 어드바이저의 빈 설정은 수정할 필요가 없다.

#### 자동생성 프록시 확인
 자동 프록시 생성기 같은 눈에 보이지 않는 결과를 초래하는 프로세스는 예외가 발생하기 전에는 확인이 불가하니 몇 가지를 꼭 확인하는 습관이 필요하다. 지금은 트랜잭션 어드바이스를 적용한 프록시 자동 생성기를 빈 후처리기 메커니즘을 통해 적용하였고, 우리가 확인할 두 가지는
 1. 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용되었는지
--> upgradeAllOrNothing()을 통해 확인
2. 아무 빈에나 트랜잭션 부가기능이 적용된 것이 아닌지
--> 포인트 컷의 클래스 필터를 통해 확인
--> 포인트컷 빈의 클래스 이름 패턴 변경해서 오류나는지 확인해라!

#### 3. 포인트컷 표현식을 이용한 포인트컷

> **포인트컷 표현식**은 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 통한 방법이다.

좀 더 편리한 포인트컷 작성 방법은 없나? 지금까지는 일일이 클래스 필터와 메소드 매처를 구현해야했다.

--> 포인트컷 표현식을 사용하자!

#### 포인트컷 표현식
AspectJExpressionPointcut 클래스를 사용해서 표현식을 사용하자.
AspectJExpressionPointcut은 클래스와 메소드의 선정 알고리즘은 표현식을 이요해 한 번에 지정할 수 있게 해준다. 마치 정규식과 같은 간단한 문자열로 복잡한 선정조건을 만드는 것이다.

--> AspectJ라는 프레임워크에서 가져왔다고 해서 AspectJ 포인트컷 표현식이라고도 부른다.

#### 포인트컷 표현식 문법
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성하는데, 포인트컷 지시자 중 가장 대표적인 것은 `execution()`이다.
![포인트컷 표현식 문법](https://leejaedoo.github.io/assets/img/%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%BB%B7_%ED%91%9C%ED%98%84%EC%8B%9D_%EB%AC%B8%EB%B2%95.jpeg)
--> 포인트컷 표현식 문법구조이다. []는 옵션이므로 생략이 가능하다.
```execution(int minus(int, int))```
--> int 타입의 리턴값, minus라는 메소드 이름, 두 개의 int 파라미터를 가진 모든 메소드를 선정하는 포인트컷 표현식이다. 
```execution(* *(..))```
--> 모든 메소드를 다 허용한 포인트컷은 위와 같이 와일드카드를 이용한다.
![](https://eundongdong.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb132bb47-7167-4f44-9471-1cd1111f734c%2FUntitled.png?table=block&id=a98f76a9-53b8-4cfa-83c9-38ad91ccb538&spaceId=f565c4bc-c9e7-4754-b9e2-8faf6d81ae69&width=1060&userId=&cache=v2)

적용을 위해서는 앞서 만든 transactionPointCut 빈을 제거하자
```execution(* *..*ServiceImpl.upgrade*(..))```와 같은 표현식을 설정하자

#### 타입 패턴과 클래스 이름 패턴
포인트컷 표현식을 사용하기 전에는 클래스 이름의 패턴을 이용해 타깃 빈을 선정하는 포인트컷을 사용했지만 포인트컷 표현식에서는 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 **타입 패턴**이다. 그래서 TestUserService클래스를 돌려도 성공하는 것이다.

--> TestUserService의 클래스 이름은 TestUserService일 뿐이지만 타입을 따져보면 TestUserService 클래스이자, 슈퍼클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용된다. 
--> 즉, ServiceImpl로 끝나는 타입 패턴의 조건을 충족하여 클래스가 성공적으로 실행되는 것이다!

#### 4. AOP란 무엇인가?
지금까지 비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리해보자
1. 트랜잭션 서비스 추상화
--> 인터페이스와 DI를 사용해서 분리하는 과정
2. 프록시와 데코레이터 패턴
--> DI를 이용해 데코레이터 패턴을 적용하여 트랜잭션 코드를 데코레이터에 남겨서 타깃과 클라이언트 사이에 존재하게 하자
3. 다이내믹 프록시와 프록시 팩토리 빈
--> 프록시 클래스를 만드는 작업이 짐이 되었기에, JDK 다이내믹 프록시를 이용해서 프록시 클래스 없이도 프록시 오브젝트를 만들었다.
4. 자동 프록시 생성 방법과 포인트컷
--> 빈마다 일일이 프록시 팩토리 빈을 등록하는 부담을 줄이기 위해 빈 생성 후처리 기법을 통해 자동으로 프록시를 만들고, 클래스 선정을 위한 포인트컷을 활용하기 위해 포인트컷 표현식을 사용했다.

#### 부가기능의 모듈화
관심사가 같은 코드를 분리해서 모드고, 분리하고, 낮은 결합도를 가진 채로 독립적이고 유연한 확장을 하는 모듈로 만드는 과정을 거쳐왔다.

트랜잭션과 같은 부가기능은 핵심기능과 같은 방법으로 모듈화하기가 힘들다. 왜냐하면, 스스로 독립적인 방식으로 존재해서는 적용되기 어렵기 때문이다.

그렇다면, 부가기능을 어떻게 독립적인 모듈로 만들 수 있나?

--> 어드바이저와 같은 방법으로 모듈을 만들어왔다!

#### AOP : 애스팩트 지향 프로그래밍
* 애스팩트 : 부가기능 모듈로 핵심적 기능을 담고 있지는 않지만 핵심기능에 부가되어 의미를 갖는 특별한 모듈이다.
* 애스팩트는 어드바이스와 포인트컷을 함께 가지고 있어서 어드바이저도 애스팩트의 한 가지 종류라고 볼 수 있다.
![독립 애스펙트를 이용한 부가기능의 분리와 모듈화](https://leejaedoo.github.io/assets/img/aspect.jpeg)

* 왼쪽 그림은 부가기능과 핵심기능이 분리되지 않은 상태로 2차원 평면 상태이다.
* 반면, 오른쪽 그림은 부가기능과 핵심기능을 애스팩트를 통해 분리한 3차원의 다면체 구조이다.

> 위와 같이 핵심적인 기능에서 부가적인 기능을 분리해서 애스팩트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 AOP(애스팩트 지향 프로그래밍)라고 부른다.

* AOP는 애스팩트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와준다.
* 즉, 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것이다.

#### 5. AOP 적용 기술
#### 1. 프록시를 이용한 AOP
**프록시로** 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만들었다.
독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 하는 것이 프록시다.

#### 2.  바이트코드 생성과 조작을 통한 AOP
**AspectJ**는 스프링처럼 다이내믹 프록시 방식을 사용하지 않는다. AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어 고쳐서 부가 기능을 직접 넣어주는 방법을 사용한다. 이렇게 프록시를 사용하지 않는 이유는?
1. 바이트코드를 조작해 타깃 오브젝트를 직접 수정해버림으로써 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다. 즉, 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다.
2. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다.

#### 6. AOP의 용어

#### 타깃
부가기능을 부여할 대상

#### 어드바이스
타깃에게 제공할 부가기능을 담은 모듈

#### 조인포인트
어드바이스가 적용될 수 있는 위치. 스프링에서는 메소드의 실행 단계

#### 포인트컷
조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈
```execution()```으로 시작

#### 프록시
클라이언트와 타깃 사이에서 투명하게 존재하면서 부가기능을 제공하는 오브젝트. 스프링은 프록시를 사용해  AOP를 지원한다.

#### 어드바이저
포인트컷과 어드바이스를 하나씩 가진 오브젝트. 어떤 부가기능을 어디에 전달할 것인가.

#### 애스팩트
AOP의 기본 모듈. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며, 보통 싱글톤 형태의 오브젝트로 존재

#### 7. AOP 네임스페이스
스프링 AOP를 적용하기 위해 추가한 빈들은 스프링 컨테이너에 의해 자동으로 인식되어 특별한 작업을 위해 사용된다.

스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

1. 자동 프록시 생성기
스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록.
빈 후처리기로 참여

2. 어드바이스
부가기능을 구현한 클래스를 빈으로 등록

3. 포인트컷
코드 직접 작성은 필요가 없고 스프링의 AspectExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다.

4. 어드바이저
스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용

* 스프링은 AOP와 관련된 태그를 정의한 aop 스키마를 제공한다.
* ```<aop:config>, <aop:pointcut>, <aop:advisor>``` 세 가지 태그를 정의해두면 그에 따라 세 개의 빈이 자동 등록된다.

### 6. 트랜잭션 속성

> 트랜잭션이란 DBMS에서 사용되는 더 이상 쪼갤 수 없는 최소 단위의 작업이다.

DefaultTransactionDefinition 오브젝트의 용도가 무엇인지 알아보자

#### 1. 트랜잭션의 정의
트랜잭션은 commit() or rollback()을 통해 모두 성공하든지 모두 실패해야한다.
이 밖에도 트랜잭션의 동작방식을 제어하는 몇 가지 조건이 있다.

####  트랜잭션 전파
**트랜잭션 전파**란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작하는지 결정하는 방식이다.

* PROPAGATION_REQUIRED : 가장 많이 사용되는 방식으로 진행 중인 트랜잭션이 없으면 새로 시작하고 있으면 이미 시작한 트랜잭션에 참여한다. DefaultTransactionDefinition 의 디폴트 속성
* PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션 시작하여 독립적으로 작동하게 한다.
* PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작하도록 만드는 속성. 진행 중인 트랜잭션 무시. 특별한 메소드만 트랜잭션  적용에서 제외하도록 할 때 사용

트랜잭션 매니저를 통해 트랜잭션을 시작하려 할 때, getTransactoin() 메소드를 사용하는 이유가 바로 트랜잭션 전파 속성이 있기 때문이다.

#### 격리수준
모든 DB 트랜잭션은 격리수준을 가진다. 서버에서는 여러 개 트랜잭션이 동시에 진행될 수 있다. DefaultTransactionDefinition의 격리수준은 ISOLATION_DEFAULT이다. 이는 DataSource의 격리수준을 따른다는 뜻

#### 제한시간
트랜잭션을 수행하는 제한시간을 정할 수 있고, DefaultTransactionDefinition의 기본 설정은 제한시간이 없다.

#### 읽기전용
트랜잭션내에서 데이터를 조작하는 시도를 막는다. 성능 향상에도 도움이 될 수 있다.

#### 2. 트랜잭션 인터셉터와 트랜잭션 속성
#### TransactionInterceptor
TransactionInterceptor를 통해 편리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있다.
TransactionInterceptor 어드바이스는 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정하는 방법을 제공한다.

* TransactionInterceptor은 PlatformTransactionManager와 Properties타입의 두 가지 프로퍼티를 가진다. 
* TransactionInterceptor은 두 가지 예외 처리 방식을 가진다. 런타임 예외가 발생하면 롤백되고 체크 예외가 발생하면 이를 의미 있는 리턴 방식으로 인지해서 커밋시킨다. 
* TransactionAttribute는 rollbackOn()이라는 속성을 통해 위와 반대로 예외를 처리하게 한다.

#### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정
트랜잭션 속성은 밑과 같은 문자열로 정의가 가능하고 트랜잭션 전파 항목만 필수이다. (순서는 상관없다.)
```PROGATION_NAME , ISOLATION_NAME, readOnly,timeout_NNN, -Exception1, +Exception2```

#### 포인트컷과 트랜잭션 속성의 적용 전략
포인트컷과 트랜잭션 속성을 정의할 때 밑과 같은 전략을 따르면 좋다.
1. 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
2. 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.(기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어라)
3. 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.
--> 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다.
--> 일단 타깃 오브젝트 내로 들어와서 타깃 오브젝트의 다른 메소드를 호출하면 프록시를 거치지 않고 직접 타깃 메소드가 호출된다. 즉, 메소드에 부가된 트랜잭션 속성이 전혀 반영되지 않는다.
--> 따라서 같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는다는 점을 주의하며 개발해야한다.

#### 4. 트랜잭션 속성 적용
트랜잭션 속성과 그에 따른 트랜잭션 전략을 UserService에 적용하자

1. 트랜잭션 경계설정의 일원화
특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다.
2. 서비스 빈에 적용되는 포인트컷 표현식 등록
```<... pointcut="bean(*Service)" />```
3. 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록
어드바이스 빈을 스프링의 TransactionInterceptor을 이용하도록 변경한다.
4. 트랜잭션 속성 테스트
get으로 시작하는 메소드는 readOnly 속성이므로 이를 위반하는 테스트를 만든다. 그렇게하고 테스트를 실행하면 ```... Connection is read-only. Queries leading to data modification are not allowed``` 라는 오류 메세지를 만나게 된다. 

### 7. 애노테이션 트랜잭션 속성과 포인트컷

> 세밀한 트랜잭션 속성 제어가 필요한 경우 직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정해서 트랜잭션 속성을 제어할 수 있다.

#### 1. 트랜잭션 애노테이션 
**@Transactional** 애노테이션을 사용하면 메소드와 타입을 타깃으로 삼아서 트랜잭션 속성 제어가 가능하다.

#### 트랜잭션 속성을 이용하는 포인트컷
![](https://eundongdong.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff167f695-9717-41ff-bcc2-582f3563dc3a%2FUntitled.png?table=block&id=7c046293-53e3-4451-97a2-3ddb97e37273&spaceId=f565c4bc-c9e7-4754-b9e2-8faf6d81ae69&width=1390&userId=&cache=v2)
* @Transactional을 이용하면 포인트컷과 트랜잭션 속성을 지정할 수 있다. 
* 트랜잭션 부가기능 적용단위는 메소드이다. 따라서 메소드마다 @Transactional을 부여하고 속성 제어가 가능하다. 
* 하지만 위의 방법은 코드가 지저분해지고 반복을 초래한다.

#### 대체정책
따라서 스프링은 @Transactional을 적용시에 4단계의 대체 정책을 이용하게 해준다.

순서를 타깃 메소드 -> 타깃 클래스 -> 선언 메소드 -> 선업 타입의 순서에 따라 @Transactional 적용 여부를 확인하고 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.

* 이렇게 대체 정책을 잘 활용하면 애노테이션을 최소한으로 활용하면서 세밀한 트랜잭션 제어가 가능하다. 
*  기본적으로 @Transactional 적용 대상은 타깃 클래스보다 인터페이스에 두는 게 바람직하지만 프록시 방식이 아닌 AOP를 사용할 때는 타깃 클래스에 두는 방법을 권장한다.
* @Transactional을 사용하려면 ```<ts:annotation-driven />``` 설정을 추가해주자

#### 2. 트랜잭션 애노테이션 적용
@Transactional을 UserService에 적용해보자. 우리는 인터페이스에 애노테이션을 적용할 것이다. 그래야 UserServiceImpl, TestUserService 양쪽에 트랜잭션이 적용되기 때문!

    @Transactional
    public interface UserService {
	    ...
	    @Transactional(readOnly=true)
	    User get(String id); // 메소드를 우선적으로 적용한다.
    }

### 8. 트랜잭션 지원 테스트

#### 1. 선언적 트랜잭션과 트랜잭션 전파 속성
스프링은 트랜잭션 전파 속성을 선언적으로 적용할 수 있는 기능을 제공한다.
![](https://eundongdong.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Facb67894-ea06-4203-a1a6-1b9067074046%2FUntitled.png?table=block&id=b18ae420-415c-4dba-a82f-3007ac7255d6&spaceId=f565c4bc-c9e7-4754-b9e2-8faf6d81ae69&width=1260&userId=&cache=v2)

**선언적 트랜잭션**이란 AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법이다.
(이와 반대로 트랜잭션 API를 이용해 직접 코드 안에서 사용하는 방법은 프로그램에 의한 트랜잭션이다.)

#### 2. 트랜잭션 동기화와 테스트
우리는 AOP를 통해 트랜잭션의 자유로운 전파를 가능하게 하고, 트랜잭션 추상화를 통해 DAO 작업들을 하나의 트랜잭션으로 묶어서 추상 레벨에서 관리가 가능하다.

트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
* 트랜잭션 매니저 : 일관된 트랜잭션 제어 가능
* 트랜잭션 동기화 : 트랜잭션 정보를 저장소에 저장하고 DAO에서 공유가능

테스트 메소드를 살펴보자

    @Test
    public void transactionSync() {
	    userService.deleteAll();
	    userService.add(users.get(0));
	    userService.add(users.get(1));
    }

--> 위의 메소드는 3개의 독립된 트랜잭션에서 실행
--> 하나의 트랜잭션으로 통합하자!
--> UserService의 메소드 호출 전에 트랜잭션을 미리 시작하면 된다.

    @Test
    public void transactionSync() {
	    DefaultTransactionDefinition txDefinition = new DefaultTransactionDefinition();
	    TransactionStatus txStatus = txManager.getTransaction(txDefinition);
	    
	    userService.deleteAll();
	    userService.add(users.get(0));
	    userService.add(users.get(1));
    }

* 트랜잭션 매니저에게 트랜잭션을 요청하면 동시에 만들어진 트랜잭션을 다른 곳에서도 사용가능하도록 동기화한다.(두 번째 줄 코드)

#### 롤백 테스트

**롤백 테스트**는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게하고 테스트가 끝나면 무조건 롤백해버리는 테스트이다.

    @Test
    public void transactionSync() {
	    DefaultTransactionDefinition txDefinition = new DefaultTransactionDefinition();
	    TransactionStatus txStatus = txManager.getTransaction(txDefinition);
	    
	    try {
		    userService.deleteAll();
		    userService.add(users.get(0));
		    userService.add(users.get(1));
		}
		finally {
			transactionManager.rollback(txStatus);
		}
    }

왜 사용하나?

--> 테스트를 진행하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전의 상태로 복구시켜주기 때문이다.
--> 어떠한 경우에도 트랜잭션을 커밋하기 않기 때문에 테스트 성공여부에 상관 없이 DB는 수정되지 않는다.
--> 이렇게 되면 여러 개발자가 하나의 공용 테스트용 DB를 사용해도 상관없다.
--> 이처럼 테스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 큰 유익이 롤백 테스트이다.

#### 3. 테스트를 위한 트랜잭션 애노테이션

#### @ContextConfiguration
이를 클래스에 부여하면 테스트 실행 전에 스프링 컨테이너를 초기화하고, @Autowired가 붙은 필드를 통해 테스트에 필요한 빈에 자유롭게 접근 가능하다.

#### @Transactional
테스트 메소드에 트랜잭션 경계가 자동으로 설정되고, 이를 이용하면 테스트 내에 모든 트랜잭션 관련 작업을 하나로 묶을 수 있다.
메소드가 클래스 속성보다 우선이다.

#### @Rollback
테스트용 트랜잭션은 테스트가 끝나면 자동으로 롤백된다. 
그래서 강제 롤백을 원하지 않으면 이 애노테이션을 메소드에 사용하면 된다. 값을 false로 설정해주면 된다.

#### @TransactionalConfiguration
클래스 레벨에 부여하는 속성으로 클래스의 메소드가 롤백되지 않고 커밋되게 한다. 

#### NotTransactional과 Propagation.NEVER
@NotTransactional을 메소드에 붙이면 트랜잭션을 시작하지 않은 채로 테스트를 진행한다.

@Transactional(Propagation.NEVER)도 같은 기능이다. 

#### 효과적인 DB 테스트
DB가 사용되는 통합 테스트는 클래스를 구분하는 것이 좋다.
그 클래스에 @Transactional을 부여하고 롤백 테스트로 만들자
테스트는 어떤 경우에도 서로 의존하면 안된다.

### 9. 정리
1. 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들자
2. 목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수 있다.
3. DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
4. 번거로운 프록시 클래스 작성은 JDK의 다이내믹 프록시를 사용하면 간단하게 만들 수 있다.
5. 다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 하고 스프링은 프록시 팩토리 빈을 제공한다.
6. 자동 프록시 생성기는 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
7. 포인트컷은 AspectJ 표현식을 사용하면 편리하다.
8. AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
9. 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는데 사용할 수 있는 전용 태그를 제공한다.
10. AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는  @Transactional 애노테이션을 사용하는 방법이 있다.
11. @Transactional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.
