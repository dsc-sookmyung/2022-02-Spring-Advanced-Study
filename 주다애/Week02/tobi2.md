## 2. 테스트

> 스프링에 있어서 중요한 가치인 **테스트**
>  테스트는 개발자에게 코드의 확신을 주고 변화에 유연하게 대처할 수 있게 하는 자신감을 주는 중요한 기술이다.



### 1. UserDaoTest 다시보기

    public class UserDaoTest{
	    public static void main(String[] args) throws SQLException{
		    UserDao dao = context.getBean("userDao", UserDao.class);
		    // test 진행
	    }
    }

1. main() 메소드 직접 호출해서
2. UserDao를 직접호출하여 테스트를 진행한다.

#### 웹을 통한 테스트의 문제점
1. 테스트를 하기 위해 준비해야 하는 과정이 너무 많다. 서비스, 컨트롤러, 뷰 모두 준비가 되어야 입력이 가능해지기 때문
2. 에러의 원인을 찾기가 힘들다.
3. 결국 테스트를 효율적으로 진행하지 못하고 원하는 결과를 얻지 못 할 가능성이 있다.

그렇다면 어떤 방식으로 테스트를 진행해야 하는가?

#### 작은 단위의 테스트

> **단위테스트**(unit test)란 관심사의 분리를 통해 나누어진 작은 단위의 코드에 대해 테스트를 수행하는 것이다.
* 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 즉, 단위는 작을수록 좋다.(물론 길고 많은 단위가 참여하는 테스트가 언제가는 필요하다.)
* 단위 테스트를 진행하면 개발자 스스로 본인 코드를 빨리 확인할 수 있다. 그래서 테스트 단위를 작고 명확하게 할수록 더 이득이다!
* 또한 테스트는 **자동으로 수행**되도록 코드를 작성해야 한다. 
   --> 테스트 코드를 별도의 테스트 클래스에 따로 빼자!
   --> 자동으로 수행되는 테스트는 자주 반복이 가능하여 언제든 코드 수정이 가능하다.

### 2. UserDaoTest 개선
위에서 봤던 UserDaoTest의 문제점은?
1. 수동 확인의 번거로움
2. 실행 작업이 번거로움

테스트의 결과가 콘솔에 출력되므로 사람 눈으로 직접 확인해야하고, 테스트를 위해서 main()메소드를 우리가 직접 실행해주어야 한다. 
**UserDaoTest를 개선해보자!**

#### 테스트 검증의 자동화
* 모든 테스트는 성공 or 실패
1. getName(), getPassword(), equals()메소드를 사용하자
테스트의 수행과 값 적용, 결과 검증을 자동화하였다.

#### 테스트의 효율적인 수행과 결과 관리

> **JUint**은 자바로 단위 테스트를 만들 때 사용하는 테스트 지원 도구(프레임워크)이다.
* JUnit은 제어의 역전(IoC)를 기반으로 동작하는 프레임 워크이다.
--> 지금은 main()메소드에서 테스트가 작동한다. 즉, 클래스 제어권을 직접 가지고 있다는 뜻으로 JUnit테스트를 진행하기에 적합하지 않다.
--> **일반 메소드로 테스트 코드를 옮기자!**

JUnit으로 테스트를 진행하려면
1. 메소드는 public으로 선언
2. 메소드에 @Test 어노테이션 추가


메소드를 재구성하면

    @Test
    public void addAndGet() throws SQLException{
	    // User 객체 세팅하기
	    assertThat(user2.getName(), is(user.getName()));
    }

* assertThat() 메소드의 첫 번째 파라미터의 값을 뒤에 나오는 매처라는 조건에 비교하는 코드. is()는 equals()와 같은 비교 기능을 가진다.
* JUnit은 assertThat()을 이용해 검증을 했을 때 원하던 결과가 아니면 AssertionError을 던지고 테스트를 중지한다.

### 3. 개발자를 위한 테스팅 프레임워크, JUnit

> 스프링을 제대로 학습하려면 JUnit의 작성 및 실행 방법을 알아야 한다.

#### 테스트 결과의 일관성

> 테스트는 코드에 변경 사항이 없다면 **항상 동일한 결과**를 내야한다.

* 지금까지 진행한 UserDaoTest는 실행 전에 디비의 USER 데이터를 모두 삭제해주어야 했다. 
* 즉, 테스트가 외부 상태에 따라 성공/실패가 달려있다는 것이다. 

UserDaoTest의 디비에 이전 테스트 때문에 중복된 데이터가 남아있을 수도 있는 문제를 해결해보자.
1. deleteAll(), getCount()메소드 추가

모든 데이터를 지워주고, 테이블의 레코드 개수를 반환하는 메소드를 만든다.

    @Test
    public void addAndGet() throws ~ {
	    dao.deleteAll();
	    assertThat(dao.getCount(), is(0));
	    // User setting
	    dao.add(user);
	    assertThat(dao.getCount(), is(1));
    }

* 처음에 deleteAll()을 호출해서 데이터를 지워주고 확인
* add()를 호출해서 데이터를 넣어주고 getCount()로 확인

2. addAndGet() 테스트 보완

get() 메소드가 정확하게 동작하는지 확인하자

     @Test
    public void addAndGet() throws ~ {
	    // user1, user2 중복되지않게 생성
	    dao.deleteAll();
	    assertThat(dao.getCount(), is(0));
	    
	    dao.add(user1);
	    dao.add(user2);
	    assertThat(dao.getCount(), is(2));
	    User userget1 = dao.get(user1.getId());
	    assertThat(userget1.getName(), is(user1.getName()));
	    // user2도 같은 방식으로 테스트
    }

3. get() 메소드 예외처리

만약 해당 id값에 해당되는 사용자가 없다면 어떻게 예외를 처리해야 하나?
1.  null과 같은 특정 값 던지기
2. id에 해당 정보 없다는 예외 던지기(이거 사용)

@Test(expected=EmptyResultDataAccessException.class)코드를 추가하자
get() 메소드에도 해당 예외를 던져주는 코드를 추가하자

#### 포괄적인 테스트

> 항상 **네거티브 테스트**를 먼저 만들어라

* DAO 메소드에 대한 포괄적인 테스트를 만들어두는 것이 훨씬 안전하다.
* 성공하는 테스트만 골라서 만들면 예외적인 상황에 대한 대처가 불가하다!
* 테스트 작성 시 부정적 케이스를 먼저 만드는 습관을 들이자

### 4. 테스트가 이끄는 개발

> **테스트 주도 개발**(TDD)는 만들고자 하는 기능의 내용을 담고 있으면서 코드를 검증도 해줄 수 있는 테스트 코드를 먼저 만들고, 테스트를 성공하게 하는 코드를 작성하는 방식의 개발 방법이다.

TDD를 따랐다면 모든 코드는 빠짐없이 테스트로 검증된 것이다!
TDD의 장점으로는
1. 테스트를 꼼꼼히 만들 수 있다.
2. 코드에 대한 피드백을 매우 빠르게 받게된다.
3. 빠르게 진행되어야 하기 때문에 자연스럽게 단위 테스트를 지향하게된다.
4. 테스트와 코드의 간격이 짧으므로 오류에 대한 대처가 빨라진다. 

#### 테스트 코드 개선

중복된 코드를 별도의 메소드로 뽑아내자

    public class UserDaoTest{
	    private UserDao dao; // 픽스처(테스트를 수행하는데 필요한 정보/오브젝트
	    
	    @Before
	    public void setUp(){
		    ApplicationContext context = 
		    new GenericxmlApplicationContext("application.xml");
		    this.dao = context.getBean("userDao", UserDao.class);
	    }
    }

* @Before 어노테이션을 붙이면 해당 메소드는 테스트 시작 전 항상 실행된다.
* @After 어노테이션을 붙이면 해당 메소드는 테스트 완료 후 실행된다.
* 둘 다 인스턴스 변수를 이용해야 한다.(로컬변수 불가)
* 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다.
--> JUnit은 각 테스트가 독립적으로 실행됨을 보장하기 위해서 매번 새로운 오브젝트를 만드는 것이다.

### 5. 스프링 테스트 적용

JUnit은 테스트가 진행될 때 마다 애플리케이션 컨텍스트가 생성된다.
애플리케이션 컨텍스트를 한 번만 만들고 여러 테스트가 공유하게 하자

#### 테스트 컨텍스트

테스트 컨텍스트는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 한다.(메소드 범위뿐만 아니라 클래스 범위에서도 공유 가능)

    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations="/applicationContext.xml")
    public class UserDaoTest{
	    @Autowired
	    private ApplicationContext context;
    }

* @RunWith을 사용해서 테스트 실행 방법 확장
* @ContextConfiguration을 사용해서 자동으로 만들어줄 애플리케이션 컨텍스트의 설정 파일 위치 지정
* @Autowired를 사용해서 테스트 오브젝트가 만들어지고 나서 자동으로 값 주입되게 만들어줌. 스프링 의존성 주입(DI)에 사용되는 특별한 어노테이션
--> @Autowired가 붙은 인스턴스 변수가 있으면 변수 타입과 일치하는 빈을 찾아서 인스턴스 변수에 주입해준다. 메소드 없이도 주입 가능!

#### DI와 테스트

현재 UserDao와 디비 커넥션 클래스 사이에는 DataSource라는 인터페이스가 있다.
인터페이스를 사이에 두고 DI를 적용하는게 테스트에도 영향을 주는가?
그렇다! DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다.
* @DirtiesContext 어노테이션을 사용하면 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
* 애플리케이션 컨텍스트 공유를 허용하지 않아서 테스트 중 변경한 컨텍스트가 뒤의 테스트에게 영향을 주게하지 않는다.

컨테이너 없는 DI 테스트(지향)

* 스프링 컨테이너를 이용해 IoC방식으로 생성되고 DI를 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI해도 된다.
* DI는 객체지향 프로그래밍 스타일이고 컨테이너는 DI를 편하게 적용하도록 도와주는 것일 뿐, 컨테이너가 있어야만 DI가 가능한 것은 아니다.

훨씬 직관적이고 이해하기 편한 코드가 나온다.

    public class UserDaoTest{
	    UserDao dao; // @Autowired X
	    @Before
	    public void setUp(){
		    dao = new UserDao();
		    // 관계설정 직접 해주기
	    }
    }

### 6. 학습 테스트

> **학습 테스트**는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리에 대한 테스트를 작성하는 방법이다.

학습테스트는 기능에 대한 검증이 목적이 아닌 사용 방법을 익히는 것이 목적인 테스트이다. 
학습테스트의 장점으로는
1. 다양한 조건에 따른 기능 쉽게 확인 가능
2. 개발 중에 테스트 코드 참고 가능
3. 제품 업그레이드 시 호환성 검증 도와줌
4. 테스트 작성에 대한 좋은 훈련
5. 기술 공부 과정의 즐거움 제공

> **버그 테스트**는 코드에 오류가 있을 시 그 오류를 가장 잘 드러내는 테스트로 일단 실패하도록 만들고 성공하도록 수정해야한다.

### 7. 정리
1. 테스트는 자동화+빠르게 진행
2. JUnit 프레임워크를 사용하자
3. 테스트 결과는 외부에 의해 변하면 안된다. 일관성 있어야 한다.
4. 테스트는 포괄적으로 작성해야한다.
5. 코드 작성과 테스트 수행 간격을 줄이자
6. 테스트하기 쉬운 코드가 좋은 코드
7. TDD를 적극 사용하자
8. 테스트 코드도 단계적 리팩토링이 필요하다.
9. 어노테이션 적극 활용(@Before, @After..)
10. @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI가능
11. 스프링 테스트 컨텍스트 프레임워크는 테스트의 성능을 향상시킨다.
12. 애플리케이션 컨텍스트는 공유 가능하다.
13. 학습 테스트와 버그 테스트를 활용하자 
