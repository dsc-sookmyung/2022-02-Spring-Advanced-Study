# 5장 서비스 추상화

## 사용자 레벨 관리 기능 추가

비즈니스 로직 추가 - 사용자 관리 기능

- 사용자의 레벨은 BASIC, SILVER, GOLD
- 처음 가입하면 BASIC
- 50회 이상 로그인하면 BASIC -> SILVER
- SILVER이면서 30번 이상 추천을 받으면 SILVER -> GOLD
- 레벨 변경 작업은 일정 주기를 가지고 일괄적으로 진행된다.

### 필드 추가

: 사용자 level 저장

- 각 레벨 코드화 → 숫자로 사용
- level Enum 이용
- User 필드 추가 : level 타입의 변수 & 로그인횟수, 추천수 추가
- UserDaoTest 테스트 수정
- UserDaoJdbc 수정

### 사용자 수정 기능 추가

- 사용자 정보 여러 번 수정될 수 있음
    - id 제외한 나머지 필드
    - 수정 정보가 담긴 user 오브젝트 전달
    - id 참고 사용자 찾아 필드 정보 update 문 이용
    
- 수정 기능 테스트 수정
    - 픽스처 오브젝트 하나 등록
    - id 제외 필드의 내용 바꾼 뒤 update() 호출
    
- userDao와 UserDaoJdbc 수정
    - UserDao 인터페이스에도 update() 메소드 추가
    - UserDaoJdbc : update()메소드 → add() 와 비슷한 방식으로 만듬
    - update() 이용 → UPDATE문과 바인딩할 파라미터 전달
    
- 수정 테스트 보완
    - 문제 : 수정해지 않아야 할 로우의 내용이 그대로 남아 있는지 확인 못함
    - 해결
        - 1. update()가 돌려주는 리턴값 확인
        - 2. 테스트 보강해서 원하는 사용자 외의 정보 변경되지 않음 직접 확인

### UserService.upgradeLevels()

주기적으로 조건 충족 여부 검사하고 레벨 조정

비즈니스 로직 담아둘 Service 클래스  만듬

- UserService
    - DAO 인터페이스 사용
    - DI 적용 → 스프링 빈으로 등록
- UserService 클래스와 빈 등록
    - UserDao 오브젝트의 DI가 가능하도록 수정자 메소드 추가
    - 빈 추가
- UserService 테스트 클래스

`upgradeLevels() 메소드`

- 레벨 관리기능 만듬
- 조건 충족하면 레벨 변경
- 레벨 변경 있는 경우에만 UserDao의 update() 이용 → DB에 반영

- upgradeLevel() 테스트
    - 레벨 변경 일어나지 않는 gold 제외
    - Basic / Silver 레벨 사용자 업그레이드 기준 되는 조건 등록

### add()

처음 가입하는 사용자 레벨 basic으로 설정

- 테스트 만들기
    - 레벨이 미리 정해진 경우
    - 레벨이 비어있는 경우
    - add()메소드 호출 → 결과 확인

### 코드 개선

1. canUpgradeLevel() 
    
    문제 : 여러가지 로직이 한데 섞여있음 - 자주변경 가능성  있는 내용과 추상적 로직의 흐름이 함께 섞임
    
    해결 : 구현에서 외부에 노출할 인터페이스 분리 작업
    
    - 한명씩 업그레이드 가능한지 확인하고 가능하면 업그레이드 한다
    - switch : 레벨을 구분, 업그레이드 조건 만족하는지 확인
    - 로직에서 처리할 수 없으면 예외 던짐
2. upgradeLevel()
    
    사용자 레벨을 다음단계로 바꿔주고 DB에 변경사항 저장
    
    문제 :
    
    - 다음단계가 뭔지 나타내는 로직 & level 필드 변경해주는 로직 함께 있음
    - 너무 노골적으로 드러남
    - 예외 처리 없음
3. Level
    
    level에 레벨의 순서와 다음단계 레벨이 무엇인지 결정하는 일 맡김
    
    - next 필드 : 다음 단계 레벨 정보 담기
    - nextLevel() : 다음 레벨이 무엇인지 알려줌
4. 사용자 정보가 바뀌는 부분 User로 옮기기
    - User 내부 정보 바뀌는것은 User가 스스로 다루는게 적절
    - User에게 레벨 업그레이드 위한 정보 변경 요청

## 트랜잭션 서비스 추상화

상황 : 레벨 조정 작업 중간 작업 중단 → 변경 작업 모두 취소시키기

확인 : 예외를 강제로 발생시키도록 코드 수정

결과 : 테스트 실패

### 트랜잭션의  경계 설정

1. 트랜잭션
    
    : 더이상 나눌 수 없는 작업의 정의
    
    - 원자성 : 작업을 쪼개서 작은 단위로 만들 수 없는 속성
    - 레벨의 업그레이드 작업인 upgrade() 메소드가 한 트랜잭션 안에서 이루어 지지 않음 → 실패
    - 예외가 발생해서 작업이 완료할 수 없다면 작업이 시작되기 전 초기상태로 돌려놓음

1. 트랜잭션 경계 설정
    - DB는 완벽한 트랜잭션 지원
        - SQL 이용중 수정이나 삭제 요청 시 일부만 삭제, 수정되지 않음
        - DB가 트랜잭션 보장함
    - 여러 개 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급하는 경우
        
        ex) 계좌이체
        
        - 출금계좌 잔고는 이체 금액만큼만 줄어듦 / 입금계좌 이체 금액만큼 증가
        - DB에 출금계좌 잔고수정 & 입금계좌 레코드 잔고 수정하는 두개의 SQL 필요
    
     
    
    > `트랜잭션 롤백`
    > 
    
    앞에서 처리한 SQL 작업을 취소시킴
    
    ex) 첫번째 SQL 성공적 실행 했지만 두번째 SQL 성공하지 전에 장애 생긴 경우
    
    > `트랜잭션 커밋`
    > 
    
    모든 SQL 수행이 성공적으로 마무리 됐다고 DB에 알려 작업 확정시키는 경우
    

### JDBC 트랜잭션의 트랜잭션 경계 설정

트랜잭션 끝나는 방법 

- 롤백 : 모든 작업을 무효화
- 커밋 : 모든 작업 다 확정

1. `트랜잭션의 경계`
    
    트랙잭션이 시작되고 끝나는 위치
    
2. JDBC의 트랜잭션
    
    하나의 Connection을 가져와 사용하다가 닫는 사이에 일어남
    
    트랜잭션의 시작과 종료 : Connection 오브젝트를 통해 이루어짐
    
3. 트랜잭션의 문제
    - UserService의 upgradeLevel() 에는 트랜잭션이 적용되지 않음
        
        → 트랜잭션 경계설정을 하지 않았음
        
    - 각 메소드마다 하나의 독립적인 트랜잭션으로 실행됨
    - 트랜잭션 설정시
        
        문제 : DAO 메소드를 호출할 때마다 Connection 객체를 파라미터로 전달해줘야 함
        
4. 비즈니스 로직 내 트랜잭션 경계설정
    
    해결 : DAO 메소드 안으로 upgradeLevels() 메소드의 내용 옮김
    
    문제 : 비즈니스 로직과 데이터 로직 한데 묶어버림
    
    해결 : 트랜잭션 경계 설정 작업을 UserService로 가져옴
    
    - SQL, JDBC API는 UserDao에 남겨둠
    - UserService에 트랜잭션 시작 종료 담당하는 최소한의 코드만 가져옴
    
    문제 
    
    - JdbcTemplate 사용불가
    - DAO의 메소드와 비즈니스 로직 담는 UserService의 메소드에 Connection 파라미터가 추가됨
    - UserDao가 더이상 데이터 액서스 기술에 독립적이지 않음
    

### 트랜잭션 동기화

1. Connection 파라미터 제거
    
    목적 : upgradeLevels() 메소드에서 생성된 Connection을 계속 파라미터로 전달/  DAO 호출용으로 사용하는 걸 피하게
    
    해결 : 트랜잭션 동기화 사용
    
    `트랜잭션 동기화` 
    
    - UserService에서 트랜잭션 시작하기 위해 만든 Connection 객체를 특별한 저장소에 보관
    - 이후 호출되는 DAO의 메소드에서 저장된 Connection을 가져다가 사용하게 하는 것
    
    첫번째 DB 흐름 작업
    
    - UserService가 Connection을 생성한다.
    - 생성한 Connection을 트랜잭션 동기화 저장소에 저장한다. 이후에 Connection의 setAutoCommit(false)를 호출해 트랜잭션을 시작시킨다.
    - 첫 번째 update() 메소드를 호출한다.
    - update() 메소드 내부에서 이용하는 JdbcTemplate이 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 객체가 존재하는지 확인한다. ((2) 단계에서 만든 Connection 객체를 발견할 것이다.)
    - 발견한 Connection을 이용해 PreparedStatement를 만들어 SQL을 실행한다. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는 JdbcTemplate은 Connection을 닫지 않은채로 작업을 마친다.
    
    결과 : 트랜잭션 아직 마치지 않음 / connection 여전히 트랜잭션 동기화 저장소에 저장되어 있음
    
    - 동일하게 userDao.update()를 호출한다.
    - 트랜잭션 동기화 저장소를 확인하고 Connection을 가져온다.
    - 발견된 Connection으로 SQL을 실행한다.
    - userDao.update()를 호출한다.
    - 트랜잭션 동기화 저장소를 확인하고 Connection을 가져온다.
    - 가져온 Connection으로 SQL을 실행한다.
    - Connection의 commit()을 호출해서 트랜잭션을 완료시킨다.
    - Connection을 제거한다.
    
    과정 중 예외가 발생하면, commit()은 일어나지 않고 트랜잭션은 rollback()됨
    
    ### 트랜잭션 서비스 추상화
    
    1. 기술과 환경에 종속되는 트랜잭션 경계설정 코드
        
        문제 : 로컬트랜잭션이 하나의 DB connection에 종속됨
        
        해결 : 글로벌 트랜잭션 방식 사용하기
        
        - 글로벌 트랜잭션
            - Connection을 통해서가 아닌 별도의 트랜잭션 관리자를 통해 트랜잭션 관리
            - 트랜잭션 매니저 통해 여러개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있음
        - JTA
            - 글로벌 트랜잭션 지원하는 트랜잭션 매니저 지원하기 위한 API
            - JTA 통해 트랜잭션 매니저가 관리하도록 위임
        - 트랜잭션 매니저
            - DB와 메시징 서버를 제어하고 관리하는 각각의 리소스 매니저와 XA 프로토콜을 통해 연결
            - 실제 DB와 메시징 서버의 트랜잭션을 종합적으로 제어할 수 있게 됨
        
        JTA를 이용해 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는**분산 트랜잭션**또는**글로벌 트랜잭션**이 가능
        
2. 트랜잭션 API의 의존관계 문제와 해결책
    
    문제 : Service에서 트랜잭션의 경계를 설정할 필요가 생기면 다시 종속됨
    
    해결 : 트랜잭션 경계설정 담당 코드가 일정 패턴 갖는 유사한 구조 → 추상화 생각
    
3. 스프링의 트랜잭션 서비스 추상화
    
    스프링이 트랜잭션 추상화 기술 제공함
    
    → 애플리케이션 내 직접 각 기술의 트랜잭션 API 이용하지 않고도 일관된 방식으로 트랜잭션 경계설정 가능
    
    UserService에 트랜잭션 추상화 방법 적용
    
    - PlatformTransactionManager : 트랜잭션 경계설정을 위한 추상 인터페이스
    - 사용할 DB의 DataSource를 생성자 파라미터로 넣으며 객체 생성
    - JDBC를 이용하는 경우에는 먼저 Connection을 생성하고 나서 트랜잭션을 시작
        - 필요에 따라 트랜잭션 매니저가 DB 커넥션을 가져오는 작업도 같이 수행해줌
        - 파라미터로 넘기는 DefaultTransactionDefinition 객체는 트랜잭션에 대한 속성을 담고 있음
    - 시작된 트랜잭션은 TransactionStatus 타입의 변수에 저장됨
    - TransactionStatus: 트랜잭션에 대한 조작이 필요할 때 PlatformTransactionManager 메소드의 파라미터로 전달해주면 됨
    - JdbcTemplate을 사용하는 DAO를 이용하는 작업을 진행
    - PlatformTransactionManager를 구현한 DataSourceTransactionManager 객체는 JdbcTemplate에서 사용될 수 있는 방식으로 트랜잭션을 관리
    - PlatformTransactionManager를 통해 시작한 트랜잭션은 UserDao의 JdbcTemplate 안에서 사용됨

1. 트랜잭션 기술 설정의 분리
    
    상황 : 트랜잭션 추상화 API 적용한 UserService코드를 JTA를 이용하는 글로벌 트랜잭션으로 전환하고 싶음
    
    해결 : PlatformTransactionManager 구현 클래스를 JTATrascationManager로 바꿈
    
    - JTATransactionManager :
        - 주요 자바 서버에서 제공하는 JTA 정보를 JNDI를 통해 자동으로 인식하는 기능을 갖음
        - 서버의 트랜잭션 매니저/서비스와 연동하여 동작하게 됨
        - 애플리케이션 서버의 트랜잭션 서비스를 이용하므로 직접 DataSource와 연동할 필요는 없음
        - DataSource도 서버가 제공해주는 것으로 사용해야 함
    
    문제 : 어떤 트랜잭션 매니저 구현 클래스를 사용할 지 UserService 코드가 알고있음
    
    해결 : 스프링 DI 방식으로 어떤 트랜잭션 매니저 구현 클래스 사용할지를 바꿈
    

## 서비스 추상화와 단일 책임 원칙

1. 수직 수평 계층구조와 의존관계
    - 기존 : 같은 계층에서 수평적 분리 → 같은 어플리케이션 로직을 담은 코드를 내용에 따라 분리
    - 트랜잭션 추상화 : 다른 계층의 특성을 갖는 코드를 분리
    
    - 수평적 구분 : 애플리케이션 로직의 종류에 따른
    - 수직적 구분 : 애플리케이션 로직과 기술
    
    → 둘다 결합도 낮음
    
2. 단일책임 원칙
    
    하나의 모듈은 한 가지 책임을 가져야 한다는 의미
    
    - 변경이 필요할 때 수정대상이 명확해짐
    - 기술이 바뀜 → 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 됨
    - 데이터를 가져오는 테이블의 이름이 바뀜 → 데이터 액세스 로직을 담고 있는 UserDao를 변경하면 됨
    - 비즈니스 로직도 마찬가지

1. 의존관계 주입 DI
- 모든 스프링 기술의 기반이 되는 핵심엔진이자 원리이며, 스프링의 가장 중요한 도구
- DI가 이루어지지 않으면 여전히 코드 사이의 결합이 남게 됨
- DI를 통해 깔끔하고 유연한 코드 작성 가능

## 메일 서비스 추상화

등급이 변경되면 메일을 보내는 서비스 만들기

### JavaMail을 이용한 메일 발송

할일

- User 테이블에 email 필드, 프로퍼티 추가
- UserDao 코드 수정
- 테스트 코드 수정

1. java 메일 발송
    
    표준메일인 java mail 이용
    

### JavaMail 이 포함된 코드의 테스트

문제 : 개발중에 메일 서버가 준비되지 않았다면?

해결 : 테스트 코드 작성 ? → 바람직하지 않음

1. 서버가 연결 안된 경우 
    - 메일 발송하는 테스트를 해야하는데 서버가 연결되지 않음
2. 서버가 연결된 경우
    
    매번 메일 보내며 테스트 하기엔 바람직하지 않음
    
    - 메일 발송 부하가 큼
    - 메일이 실제로 발송되어버림 → 테스트용 생성해도 서버 부담

해결방안 : 개발 중이나 테스트 수행시 javaMail을 대신할 수 있는 동일한 인터페이스 갖는 코 

### 테스트를 위한 서비스 추상화

1. JavaMail을 이용한 테스트의 문제점
    
    : JavaMail의 API는 인터페이스로 만들어져서 구현을 바꿀 수 있는 것이 없음
    
    - javax.mail.Session 클래스
        - session을 만들어야만 메일 메세지 생성 가능
        - session이 private 클래스임
        - 테스트용으로 사용 불가
    - 해결
        - 서비스 추상화 적용
    
2. 메일 발송 기능 추상화
    
    스프링이 MailSender라는 인터페이스를 제공
    
    MailSender구현 추상화 클래스 
    
    - 다른 메세징 서버 API를 이용해도 MailSender를 구현한 클래스를 만들어 DI하여 적용가능
    - UserSevice : MailSender 인터페이스를 통해 메일을 보낸다는 사실만 알면 됨
    - MailSender을 구현한 클래스가 바뀌더라도 새로 주입만 해주면 됨
    
    문제 : 메일 발송 작업에 트랜잭션 빠짐
    
    해결 : 메일 발송 기능에 트랜잭션 적용
    
    1.  발송 대상을 별도 목록에 저장
    
    - 메일을 업그레이드 할 사용자 발견했을 때 마다 발송 x
    - 업그레이드 작업 끝났을때 한번에 전송
    - 단점 : 메일 저장용 리스트등을 파라미터로 갖고 다녀야됨
    
    2. MailSender 개념 확장하여 메일전송에 트랜잭션 개념 적용
    
    - 메일 전송용 클래스 따로 만듬
    - send() 호출해도 실제로 메일 발송하지 않고 저장만
    - 업그레이드 작업 끝나면 저장된 메일 다 전송, 예외 발생하면 다 취소
    

### 테스트 대역

테스트용으로 사용되는 특별한 오브젝트들 있음

테스트 대상인 오브젝트의 의존 오브젝트가 됨

`테스트 대역`

- 테스트 환경에서 테스트 대상이 되는 객체의 기능을 충실하게 수행하면서
- 테스트를 자주 실행할 수 있도록 하는 객체

1. 테스트 스텁
    - 테스트가 관심을 가지는 대상 객체의 의존 객체로 존재
    - 테스트가 정상적으로 수행될 수 있도록 돕는 것
    - 리턴값이 있는 메소드를 이용하는 경우 테스트 스텁에 필요한 정보를 리턴하도록 구현해야 함
    
2. 목 객체
    
    : 테스트 대역 중에서 테스트 대상으롭터 전달받은 정보를 검증할 수 있도록 설계됨
    
    - 테스트 객체가 정상적으로 실행되도록 도와줌
    - 테스트 객체와 자신 사이에서 일어나는 커뮤니케이션 내용을 저장
    - 테스트 결과를 검증하는 데 활용하게 함
    - 테스트 대상이 받게 될 입력 값을 제어하면서 그 결과가 어떻게 달라지는지 확인
    
3. 목객체 필요성 
    - 테스트 대상 객체는 테스트로부터만 입력을 받는 것이 아님
        
        → 테스트가 수행되는 동안 실행되는 코드는 테스트 대상이 의존하고 있는 다른 의존 객체와 커뮤니케이션하기도 함
        
    - 테스트 대상 객체가 의존 객체에게 출력한 값에 관심이 있을 경우
        - 이 정보는 테스트에서는 직접 알 수가 없음
        - 테스트 대상과 의존 객체 사이에 주고받는 정보를 보존해두는 기능을 가진,테스트용 의존 객체인 Mock 객체 만들어 사용
    - 테스트 대상 객체의 메소드 호출이 끝남 → 테스트는 목 객체에게 테스트 대상과 목 객체 사이에서 일어났던 일에 대해 확인을 요청 → 그것을 테스트 검증 자료로 삼을 수 있음