# 템플릿

템플릿 : 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 자유롭게 변경되는 성질을 가진 부분으로부터 독립 시킴

## 문제 DAO의 변화

### 1.  초난감 DAO

문제 : 에러났을때 리소스 반환 못함, 리소스 고갈되면 서버가 중단


>  풀 (Pool) 운영방식
> : 풀 안에 제한된 수의 리소스 만들어 두고 필요할 때마다 할당함, 반환하면 다시 풀에 넣음
>-  매번 리소스 생성 x, 미리 만든 리소스 돌려가며 사용
>-  빠르게 반환하지 않을 경우 리소스 고갈
>  - close() :   리소스 다시 pool로 돌려줌

목표 : 예외 상황에서도 connection, PrepareStatement, close() 메소드가 반드시 호출되어야 됨 (=반환)

해결 : try/ catch / finally 사용

### 2.1  try/catch/finally
try : 문제가 발생할 것 같은 코드
catch : 예외 발생 시 부가적 서비스
finally : 반드시 실행 될 코드

어느 시점 error 가 발생하느냐에 따라 어떤 close() 호출할지 달라짐
null일 경우 NullPointerException 발생
- db connection 가져오던 중
    - ps, c = null
- p.s. 생성중
    -  ps = null, c= close() 가능
- p.s. 실행 중 예외
    -  ps, c= close() 가능


### 2.2  조회용 JDBC
상황 : connection, preparedStatement에 ResultSet 추가
해결 : User 등록된 수 가져오기 -  getCount() 메소드 예외처리


### 3.1 변하는 부분 method 추출
>기존 문제 : try/ catch/ finally 2중 중첩 , 매 메소드마다 반복, 실수 일어날 경우 폭탄 같은 code 됨

해결
-  변하는 부분 method 추출

문제
- 분리시킨 method ->매 DAO 마다 확장
- 남은 코드 -> 재사용 필요

### 3.2  Template method 패턴 이용
기존 문제 : 메소드로 분리 시킨 부분은 오히려 확장이 필요함

해결
- **상속 통해 자유롭게 확장**
- template method 패턴 이용
- 슈퍼 클래스 : 고정된 jdbc - try/catch/finally
- 서브 클래스 : ps 확장

### 4. 전략패턴
문제 : DAO 로직마다 상속 통해 새로운 클래스 이용
해결 : obj 둘로 분리, interface 통해 의존

- 변하는 부분 = 전략 = 확장 : interface 통해 위임
- 변하지 않는 부분 = context

but DI 적용할 수 없음

### 5. DI 적용 :  interface
문제 : context가 어떤 전략 쓸지 직접 알고 있음
해결 : context를 메소드로 분리

context가 어떤 전략 사용할지 알고있음 -> client 가 선택하도록
client : 전략 obj 생성, context 전달

클라이언트와 클래스 완전 분리 x 전략패턴 모습 갖춤
> 마이크로 DI
> IoC 컨테이너의 도움 없이 코드내에서 적용한 경우
>  => DI가 작은 단위 코드와 메소드 사이에서 일어남
> 1. 클라이언트가 오브젝트 팩토리의 책임 함께 지는 경우
> 2. 클라이언트와 전략이 결합된 경우
> 3. 클라이언트와 DI 관계에 있는 두 obj가 한 클래스 안에 있는 경우


### 6. 로컬 클래스
문제 :
- DAO 메소드마다 새로운 interface 구현 class 만들어야됨
-  부가적 정보가 있는 경우 (user) -> obj 전달받는 생성자, 저장할 인스턴스 변수 생성해야됨

해결 : 전략 클래스를 로컬 클래스로 정의 (특정 메소드에서만 사용)

1. add statement가 add() 메소드에서만 사용 -> 바로 정의 : 클래스수 증가 x
2. 자신이 선언된 곳 접근 o -> user 정보 바로 이용 가능
    - 내부 메소드 : 정의된 method의 로컬 변수에 직접 접근 간으
    - 내부 -> 외부 사용 : 외부에서 final 변수 선언
> 로컬클래스
>- 자신의 정의된 class의 obj 안에서만 만들어 질 수 있음
>- method 레벨에 정의 - 선언된 메소드 내에서만 사용

>익명 내부 클래스
>- 내부 클래스 이름 제거
>- 선언과 동시에 obj 생성

## 컨텍스트와 DI

인터페이스 사용하지 않고 DAO와 밀접 관계 갖는 Class에 DI 적용하기

### 1. class 분리
문제 : context를 UserDAO 밖에서 못씀
해결 : UserDao 밖으로 context 분리(= JDBC context를 스프링 빈으로 등록)

=> 인터페이스가 없는 DI 형성됨
그만큼 긴밀하고 끈끈한 관계

특징
- JdbcContext가 싱글톤 빈으로 등록
- JdbcContext가 다른 빈을 DI 받기 위해 스프링 빈으로 등록

> 장점 : 오브젝트 사이 실제 의존관계가 설정파일에 명확히 드러남
> 단점 : 구체적인 class와의 관계가 설정에 직접 노출됨

### 2. DAO 내부에 DI 직접 적용 (수동 DI)
상황 : 인터페이스가 없을 정도의 긴밀한 관계이니 Dao에 DI를 맡겨보자

- Dao가 obj의 생성과 초기화 전부 책임짐
- 스프링 설정파일에 userDao와 datasource 두개 빈 정의
- Jdbc context 오브젝트 만들며 DI 받은 datasource 오브젝트 를 생성자 메소드로 주입

>장점 : jdbc context가 userDao 내부에서 만들어져 관계가 외부에 드러나지 않음
단점 : 여러 오브젝트 사용되어도 jdbc context 싱글톤으로 생성 x, 부가 코드 필요


## 템플릿과 콜백
템플릿 : context = 반복되는 작업
콜백 : 익명 내부 클래스로 만들어진 obj = 확장


> 템플릿 : 고정된 틀 안에 바꿀 수 있는는 부분 넣어서 사용하는 경우
> - 슈퍼클래스 : 고정된 틀 로직
>- 서브 클래스 : 바뀌는 부분
>
> 콜백 : 실행 되는 것을 목적으로 다른 오브젝트 메소드에 전달되는 오브젝트
> 메소드 자체를 파라미터로 넘길 수 없어 메소드가 담긴 오브젝트 전달

### 1. 동작원리
콜백
- 하나의 메소드 가진 인터페이스를 구현한 익명 내부 클래스로부터 만들어짐
- 템플릿의 메소드 호출 시 파라미터로 전달됨
- 클라이언트 메소드에 잇는 정보와 템플릿이 제공한 참조정보 이용하여 수행,결과 템플릿에 돌려줌

클라이언트
-  템플릿 안에서 실행될 로직 담은 콜백 오브젝트 생성, 콜백이 참조할 정보 제공

템플릿
- 내부에서 생성한 참조정보 가지고 콜백 obj 메소드 호출


>템플릿/ 콜백 방식 특징
>- 매번 메소드 단위로 사용할 obj 전달 받음
>- 자신을 생성한 클라이언트 메소드 내의 정보 직접 참조함
>- 클라이언트와 콜백이 강하게 결합


### 2. 콜백 분리와 재활용 (메소드 분리)
이전 jdbc 예시 적용하기
해결 : 바뀌지 않는 부분 분리시켜 메소드로 만들기 -> sql 부분 따로 담기

### 3. 콜백과 템플릿의 결합 (전체 DAO 공유)
목표 : 모든 dao 가 사용할 수 있도록 하기
해결 : 새로운 class 만들어 그 안으로 옮기기

템플릿은 메소드이므로 콜백 생성과 템플릿 호출이 담긴 메소드 옮겨도 문제 없음
외부 접근 가능하게 public으로 선언

### 4. 중복제거
문제 : 중복되는 코드있는 경우 응용
해결 : 한줄씩 읽는 buffer reader 사용하여 메소드로 따로 분리

### 5. 제네릭스 이용한 콜백 인터페이스
제네릭스 : 자바 타입 언어 + 타입 파라미터 개념 도입
사용 방법 : 타입 파라미터 이용
- 타입 파라미터 T를 갖는 인터페이스 타입 오브젝트와 초기값 받음 -> T타입 변수에 정의
- 타입 파라미터로 선언된 메소드 호출, 처리, 타입 파라미터 결과 리턴

## 스프링의  JDBC 템플릿
JdbcTemplate : 스프링이 제공하는 JDBC 코드용 기본 템플릿
기존 jdbcContext를 수정해보자

### 1. update()
update() : 기존과 대응되는 JdbcTemplate의 인터페이스 메소드
- deleteAll() 메소드 : preparedStatementCreator타입 콜백을 받아 사용
- executeSql() 메소드 :  미리 준비된 콜백 만들어 템플릿 호출도 해줌
    - 파라미터로 SQL 문장 전달
- add() 메소드: preparedStatement 만들고 파라미터를 순서대로 바인딩 해줌

### 2. queryForInt()
SQL 쿼리 실행 후 ResultSet 통해 결과 값 가져옴
콜백 두개 등장
- 1. preparedStatementCreator : 템플릿으로부터 커낵션 받고 preparedStatement 돌려줌
- 2. ResultSetExtractor : 템플릿으로부터 ResultSet받고 추출한 결과 돌려줌

### 3. queryForObject ()
get() 메소드에 적용
차이점
- ResultSetExtractor - ResultSet 한번만 전달받아 알아서 추출 작업 진행, 최종결과 리턴
- RowMapper - ResultSet의 로우 하나 매핑하기 위해 사용, 여러번 호출

코드 분석
- queryForObject() : SQL 실행하면 하나의 로우 얻을 것이라고 기대 -> RowMapper 호출
- Results : 가리키고 잇는 로우의 내용 User 오브젝트에 담아 리턴해줌

### 4. query()
상황 : RowMapper 더 사용

1. 테스트 코드 작성
    - User 타입 오브젝트 db등록
    - getAll() 호출, 결과 돌려받기
    - +a) 유저 하나씩 추가하여 매번 getAll() 실행

2. 실제 코드 구현
    - query() 메소드 사용 : 타입 파라미터로 넘기는 rowMapper<T> 콜백 오브젝트에서 결정됨
    - 첫번째 파라미터 : 실행 쿼리 넣기
    - 마지막 파라미터 : rowMapper 콜백 호출
    - RowMapper : 현재 로우의 내용을 유저 타입의 오브젝트에 매핑후 돌려줌

3. 테스트 보완
    - 예외적인 조건 빼먹지 않기
    - 네거티브 테스트 실행

### 재사용 가능한 콜백의 분리
상황 : UserDao 코드 살펴보기

1. DI 위한 코드 정리
    - 인스턴스 변수, 수정자 메소드 제외하고 정리하기
2. 중복 제거
    - get()과 getAll()의 RowMapper 내용이 똑같음
    - ResultSet 로우 하나를 유저 오브젝트 하나로 변환 기능 동일
    - 콜백 하나만 만들어 공유
3.  템플릿, 콜백 패턴과 UserDao
    - UserDao : 유저 정보 DB에서 가져오거나 조작하는 방법 - 핵심로직
    - JdbcTemplate : JDBC API 책임지는 방식 , 리소스 반납 , 디비 연결 어떻게 가져올지 등
    - UserDao와 영향 주지 않음. 낮은 결합도 유지

욕심낼 부분
1. UserDao 빈의 DI용 프로퍼티 만들기
2. SQL 외부 리소스에 담고 이를 읽어와 사용하는 것 개선
