# 6장 AOP (2)

### 스프링 AOP

1. 자동 프록시 생성
    
    문제 : 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해야됨 → 중복
    
    해결 : 빈 후처리기를 이용한 자동 프록시 생성기
    
    BeanPostProcessor 인터페이스를 구현해서 만든 빈 후처리기
    
    - 스프링 빈 오브젝트로 만들어지고 난 후 빈 오브젝트를 다시 가공할 수 있게 해줌
    - DefaultAdvisorAutoProxyCreator 제공
        - 어드바이저 이용한 자동 프록시 생성
        - 빈 후처리기가 빈으로 등록 → 빈 obj 생길때마다 빈 후처리기 보내 후처리 작업 가능
    
    자동 프록시 생성 빈 후처리기
    
    - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장, 프록시를 빈으로 대신 등록
    - 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용 → 전달받은 빈이 프록시 적용 대상인지 확인
    - 프록시 적용 대상 : 내장된 프록시 생성기에 빈에 대한 프록시를 만들게 함
    - 만들어진 프록시에 어드바이저를 연결
    - 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용
    
2. 포인트 컷
    
    포인트컷의 두가지 메소드
    
    - `ClassFIlter getClassFilter()` - 프록시를 적용할 클래스 인지 확인
    - `MethodMatcher getMethodMatcher` - 어드바이스 적용할 메소드 인지 확인
    
    이전까지는 메소드 매처만 이용해서 메소드 선별함.
    
    클리스필터 사용하면 프록시를 적용할 클래스인지 판단 후 적용대상이면 메소드매처를 이용하게 함
    
3. 포인트컷 표현식
    
    포인트컷 표현식 
    
    - 포인트컷을 작성할 수 있도록 정규식이나 표현식 언어를 사용한 방법
    - 간단한 문자열로 복잡한 선정조건을 쉽게 만들어낼 수 있는 강력한 표현식을 지원
    
    AspectJExpressionPointcut 클래스 사용
    
    - 포인트컷 표현식 통해 한번에 지정할 수 있게 해줌
    - 기존 : Pointcut 인터페이스 구현위해 클래스 필터와 메소드 매처 두가지 제공했어야 됨
    
    AspectJ 포인트컷 표현식
    
    - 포인트컷 지시자 이용해 작성 - `execution()`
    - `execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])`
    - 대괄호 접근제한자, 이름패턴의 타입패턴, 예외패턴 생략 가능
    - 모든 항목 적용시 * 사용
    - execution()외 bean(), @Transcation 도있음
    - 주의 : 클래스 이름에 적용되는 패턴이 클래스 이름 패턴이 아니라 타입 패턴임
        
        > 타입 패턴 적용 → 어떤 클래스가 상속받고 있는 부모 클래스 타입, 구현한 인터페이스 타입까지 적용 가능.
        > 

### AOP란 무엇인가?

1. 트랜잭션 적용 과정
    
    UserService에 트래잭션 적용하며 생긴 문제 과정
    
    1) 트랜잭션 경계 설정 코드를 비즈니스 로직 담은 코드에 넣음
    
    - 문제 : 특정 트랜잭션 기술에 종속된 코드
    - 해결 : 서비스 추상화 기법 적용
    
    2) 트랜잭션 어떻게 다룰것인지 관련 코드 제거
    
    - 문제 : 비즈니스 코드에 트랜잭션의 잔재 남음
    - 해결 : DI 이용해 데코레이터 패턴 적용
    
    3) 프록시 이용해 비즈니스 로직에서 트랜잭션 코드 제거
    
    - 문제 : 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 매번 만들어야됨
    - 해결 : JDK 다이내믹 프록시 기술 적용
    
    4)  
    
    - 문제 : 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정
    - 해결 : 빈 후처리기 이용 → 자동으로 프록시 만들어주기

1. AOP
    
     : Aspect Oriented Programming
    
    기존 작업
    
    - 트랙잭션 같은 부가기능 → 핵심기능과 같은 방식으로 모듈화 하기 어려움
    - 부가기능 : 스스로 독립적인 방식으로 존재해서는 적용되기 어려움
    - 타깃의 코드 안에 침투하거나 긴밀히 연결되야 됨
    - `핵심기능에 부여되는 부가기능을 효과적으로 모듈화하는 방법`을 찾는 것
    
    에스펙트 (**Aspect)**
    
     : 부가기능 모듈을  객체지향에서 사용하는 obj와 다른 특별한 이름
    
    - 애플리케이션 구성하는 중요한 요소
    - 핵심 기능에 부가되어 의미 갖는 모듈
    - 부가될 기능을 정의한 코드인 `어드바이스`와, 어드바이스를 어디에 적용할지를 결정하는 `포인트컷`을 함께 갖고 있음
    - 에스펙트 = 애플리케이션을 구성하는 한가지 측면
    
    > **AOP**
    > 
    > 
    > **애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법** 
    > 
    
2. AOP 적용 기술
    
    스프링의 AOP
    
    - 프록시 방식의 AOP
    - 프록시로 만들어 DI로 연결된 빈 적용
    - 타깃의 메소드 호출 시 참여, 부가기능 제공

AspectJ

- 프록시 사용하지 않는 AOP
- 타깃 obj 부가기능 직접 넣어줌 → 직접적 방법
- 컴파일된 타깃의 클래스 파일 자체를 수정
- or 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작

AspectJ 복잡한 방법 사용 이유

- 바이트 코드 조작하여 타깃 오브젝트 직접 수정 →
    - DI 컨테이너 도움 받아 자동 프록시 생성방식 사용하지 않아도 AOP 적용 가능
- 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능
    - 바이트코드 직접 조작하여 AOP 적용시 오브젝트의 생성, 필드 값이 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여 가능

1. AOP의 용어
    - 타깃 : 부가기능 부여할 대상
    - 어드바이스 : 타깃에게 제공할 부가기능 담은 모듈
    - 조인 포인트 : 어드바이스가 적용될 수 있는 위치 / 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 됨
    - 포인트 컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈
    - 프록시 : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 obj
    - 어드바이저 : 포인트컷과 어드바이스 하나씩 갖고 있는 오브젝트 / 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈
    - 에스팩트 : AOP의 기본 모듈 / 한개 ,그이상 포인트컷과 어드바이스 조합으로 만들어짐, 싱글톤 형태 obj

### 트랜잭션 속성

1. 트랜잭션 전파
    
    DefaultTransactionDefinition 
    
    - 트랜잭션 가져올 때 파라미터로 트랜잭션 매니저에게 전달됨
    - **TransactionDefinition 인터페이스** 구현
        - 트랜잭션 동작방식에 영향 줄 수 있는 네가지 속성 정의함
        
    
    1) 트랜잭션 전파
    
    : 이미 진행중인 트랜잭션 있을 때 혹은 없을 때 어떻게 동작 할 것인지 결정하는 방식
    
    - 트랜잭션 전파 속성
        - PROPAGATION_REQUIRED : 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 참여 / 가장 많이 사용 /  DefaultTransactionDefinition도 이 속성을 사용
        - PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션을 시작
        - PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작하도록 만듬 / 하나의 트랜잭션 내에 여러 메소드 중 특별한 메소드만 트랜잭션 적용에서 제외하려고 할 때 유용하게 쓸 수 있음
    - 트랜잭션을 시작하려고 할 때 getTransaction() 사용 이유 : 트랜잭션 전파 속성 때문
    - 진행중인 트랜잭션 존재 여부 따라 새로운 트랜잭션 시작 o or 이미 진행중인 트랜잭션에 참여하기만 가능
    
    2) 격리 수준
    
    - 모든 DB 트랜잭션은 격리 수준 갖고 있어야 함
    - 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 제어
    - DefaultTransactionDefinition에 설정된 격리수준 : ISOLATION_DEFAULT
    
    3) 제한 시간
    
    - 트랜잭션을 수행하는 제한시간 설정 가능
    - DefaultTransactionDefinition의 기본 설정 : 제한시간 x
    
    4) 읽기전용
    
    - 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음
    - 데이터 액세스 기술에 따라서 성능이 향상될 수도 있음

1. 포인트컷과 트랜잭션 속성의 사용 전략
    
    프록시 방식 AOP 
    
    - 같은 타킷 오브젝트 내의 매소드 호출 시 적용되지 않음
    - 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능
        - 클라이언트 : 인터페이스 통해 타킷 오브젝트 사용하는 다른 모든 오브젝트들
    - 타깃 오브젝트가 자기 자신의 메소드를 호출할 떄는 프록시를 통한 부가기능의 적용이 일어나지 않음
    
    타깃안에서 호출시 프록시 적용안되는 문제 해결 
    
    - 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제하는 방법
    - AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용하는 방법

트랜잭션 경계 설정 일원화

- 경계 설정의 부가기능을 여러 계층으로 중구난방 쓰기 x
- 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직

### 어노테이션 기반의 트랜잭션 속성과 포인트컷

1. 트랜잭션 인터셉터
    
    메소드별로 다른 트랜잭션 정의 적용 위해 어드바이스 기능 확장 해야됨
    
    - TransactionInterceptor : 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공
    - Properties 타입의 transactionAttributes : rollbackOn() - 예외가 발생하면 롤백을 할 것인가를 결정하는 메소드
    - 
    
2. @Transational 어노테이션
    
    Transactional
    
    - 타겟 : 메서트와 타입 (메서드, 클래스, 인터페이스)
    - TransactionAttributeSourcePointcut 포인트컷이 부착된 모든 오브젝트를 타겟 오브젝트로 알아서 인식함

1. 대체 정책(fallback)
    - @Transactional 적용할 때 4가지 대체 정책 이용하게 해줌
    - 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입 순서로 @transactional 이 적용 됐는지 확인
    - 가장 먼저 발견되는 속성 정보 사용
    

### 트랜잭션 지원 테스트

1. 선언적 트랜잭션과 트랜잭션 전파 속성
    - 선언적 트랜잭션 : AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정 할 수 있게 하는 방법
    - 프로그램에 의한 트랜잭션 : TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법
    - 특별한 경우 아니면 전자 사용
    
2. 트랜잭션 매니저와 트랜잭션 동기화
    
    **트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화**
    
    - PlatfromTranscationManager 인터페이스를 구현한 트랜잭션 매니저 → 구체적인 트랜잭션 기술 종류 상관없이 일관된 트랜잭션 제어 가능
    
    트랜잭셕 동기화 기술
    
    - 트랜잭션 전파 위해 중요한 역할
    - 진행중인 트랜잭션 여부 확인
    - 트랜잭션 전파 속성에 따라 이에 참여할 수 있게 함

@Transactional

- 복잡한 코드 작성하지 않고도 트랜잭션 적용 가능
- 속성, 기능 적용가능
- 메서드 레벨 적용 가능,  클래스 레벨 적용 하면 클래스 내 모든 메서드에 트랜잭션 적용됨
- 테스트에 적용된 @Transactional은 자동으로 롤백되는 것이 기본 설정

@Rollback

- @Rollback(false)라고 선언하면 롤백되지 않음
- 기본값 true
- 메서드 레벨에서만 적용 가능

@TransactionConfiguration

- 클래스 레벨 부여
- 클래스 아래 메서드 모두 적용
    - 특정 메서드에 속성 지정되어 있으면 무시 당함

@NotTransactional

일부는 트랜잭션 설정을 하고싶지 않을때 부착

- 트랜잭션이 필요한 테스트와 그렇지 않은 테스트를 분리해서 작성하는 것이 더 바람직함
- @Transactional(propagation = Propagation.NEVER)를 적용하면 트랜잭션이 시작되지 않음