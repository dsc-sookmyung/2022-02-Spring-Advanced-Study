
# Test code
기존 ) 웹을 통한 테스트
- 모든 기능들 다 만들고 나서야 테스트 가능
- 어디서 에러 났는지 확인 어려움

### 단위테스트
테스트 가능하면 단위로 쪼개서 실행 ( 관심사 분리 적용 )
단위 테스트 : 작은 단위의 코드에 대해 테스트 수행

## UserDaoTest
1. 장점
- 테스트 과정이 자동으로 진행
- 자주 반복 가능
2. 문제점
- 수동 확인 : 테스트 결과 확인은 사람의 몫
- 실행 작업의 번거로움
3. UserDaoTest 개선
- 테스트 검증 자동화 :
  에러 발생 시 쉽게 확인 가능. 메소드 기능 일치 하지 않으면 에러 메시지 발생시키기. 둘다 성공하면 성공 메세지 발생


## JUnit을 이용한 테스트 코드 전환
- JUnit : 자바 테스팅 프레임 워크
- 프레임워크 : 클래스에 대한 주도권 받아 주도적으로 애플리케이션의 흐름 조정

기존 ) main() 메소드 사용 : main이 모든 주도권 가짐 -> 적합 x
메소드 분리 후 JUnit 요구 조건 따르기
>JUnit의 요구 조건
>1. 메소드가 public으로 선언될 것
>2. 메소드에 @Test 어노테이션 붙이기

### if- else
테스트 결과 검증하는 if-else 문장 -> JUnit 제공 메소드 대체

    assertThat(user2.getName(), is(user,getName()));
- if = assertThat
- 첫번째 파라미터와 매쳐 비교 (is도 매쳐, equals()로 비교)
- 일치하면 다음으로 넘어감
- 메소드 실행 완료 시 테스트 성공 인식함

## Test code 작성
1. 테스트 결과의 일관성 : 외부환경에 상관없이 동일한 결과
- Unit : 하나의 클래스 안에 여러 테스트 메소드 가능
    - @Test, public 접근자, return 값 void, 파라미터 x

2. 예외상황 테스트
   EmptyResultDataAccessException 이용
- 상황 : get() 이용시 id에 해당정보가 없을 경우 -> 정보 전달
- 결과 : EmptyResultDataAccessException가 던져지면 테스트 성공, 정상적 작업 마치면 에러

>항상 네거티브 테스트를 먼저 만들것


## Test code 개선
문제 : 스프링 애플리케이션컨텍스트 만드는 부분 + userDao 가져오는 부분 중복
해결 : JUnit에서 제공하는 기능 사용
- 반복되는 준비작업 별도의 메소드에 넣음
- 테스트 메소드 실행하기 전에 먼저 실행시켜줌

### @Before
: @Test 메소드 실행되기 전 먼저 실행되야 하는 메소드 정의
각 테스트 메소드에 반복적으로 나타난 코드 빼서 새로 메소드로 만듬

>JUnit이 테스트 메소드 수행하는 과정
>1. @Test가 붙은 public, void형이며 파라미터가 없는 메소드 모두 찾음
>2. 테스트 클래스의 obj 만듬
>3. @Before	 메소드 실행
>4. @Test 메소드 호출, 값 저장해둠
>5. @After 메소드 실행
>6. 나머지 테스트 메소드 2-5 반복
>7. 모든 결과 종합해서 돌려줌

## TDD
1. 테스트 주도 개발 (TDD)
- 만들고자 하는 기능의 내용 o
- 만들어진 코드 점증할 테스트 코드
- 테스트 성공하게 해주는 코드 작성

2. TDD 특징
- 테스트 먼저 만들고 테스트가 성공하도록 하는 코드만 작성
- 코드 작성하면 바로 테스트 실행 가능
- 자연스러운 단위테스트 가능

3. TDD 장점
   코드 만들어 테스트를 실행하는 간격이 짧음
- 너무 많은 코드 작성 x
- 애플리케이션 코드보다 상대적으로 작성하기 쉬움, 독립적
- 작성시간 짧음