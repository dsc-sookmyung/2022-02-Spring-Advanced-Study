# 6장 AOP

AOP 등장 배경, 스프링에 도입 이유, 적용을 통해 얻을 수 있는 장점 알아보기

## 트랜잭션 코드

기존 서비스 추상화 기법 통해 트랜잭션 코드를 분리했음

문제 : 비즈니스 로직이 주인이어야 하는데 트랜잭션 코드가 더 많음(트랜잭션 경계 설정 )

### 메소드 분리

기존 트랜직션 경계 설정 코드와 비즈니스 로직 설정 코드가 분리되어있음

- 두 코드 성격 다름
- 두 코드간에 주고받는 정보 없이 완벽히 독립적

⇒ 비즈니스 로직 담당 코드를 메소드로 추출

### DI를 이용한 클래스 분리

문제 : 여전히 트랜잭션 담당 코드가 UserService에 포함됨

해결 : DI를 이용하여 클래스 분리 → 인터페이스

1. UserService 인터페이스
    - 기존 UserService 클래스 → UserServiceImpl로 변경, 인터페이스 구현하도록
    - UserService : 클라이언트가 사용할 핵심 로직 담음
    
2. 분리된 트랜잭션 기능
    
    UserServiceTx 
    
    - 같은 인터페이스를 구현한 다른 오브젝트에게 작업을 위임
        - 사용자 관리 로직 다른 UserService 구현 오브젝트에 기능을 위임
    - 트랜잭션의 경계설정

1. 트랜잭션을 위한 DI 설정
    
    UserService 인터페이스 통해 로직 이용시 트랜잭션 담당 obj 먼저 사용
    
    이후 비즈니스 관리 로직 담당 obj 수행
    

<aside>
👩🏻‍💻 트랜잭션 경계 설정 코드 분리의 장점

1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 됨
2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있음
</aside>

## 고립된 단위 테스트

좋은 테스트 방법 : 가능한 한 작은 단위로 쪼개서 테스트하는 것

문제 : UserService는 UserDao, TransactionManager, MailSender라는 세 가지 의존관계 갖고 있지만 각 의존관계 뒤에 여러 obj, 서비스, 환경 등이 합쳐져서 테스트 됨

### 테스트 대상 obj 고립시키기

테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요 있음 → 테스트를 위한 대역 사용

1. 테스트를 위한 UserServiceImpl 고립
    
    문제 : upgradeLevels() 같은 메소드는 void로, 리턴값을 확인 할 수 없음
    
    해결 : 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인 작업
    
    - UserDao의 update() 메소드를 호출하는 것을 확인 →  DB에 그 결과가 반영될 것
    - UserServiceImpl과의 사이에서 주고받은 정보를 저장해 뒀다가 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들기

### 단위 테스트와 통합 테스트

테스트의 단위 정하기 나름. but 하나의 단위에 초점을 맞춘 테스트 중요

1. 단위테스트 
    
    : 하나의 단위에 초점을 맞춘 테스트
    
    - 테스트 대상 클래스를 목 오브젝트 등 테스트 대역을 이용해 고립시켜 테스트 하는 것

1. 통합테스트 
    - 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트
    - 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

1. 단위테스트 vs 통합테스트 언제 사용?
    - 단위 테스트 먼저 고려
    - 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로
    - 단위 테스트로 만들기가 어려운 코드 → 대표적인 게 DAO
    - DAO 테스트는 DB라는 외부 리소스를 사용하기 때문에 통합 테스트로 분류
        - 코드에서 보자면 하나의 기능 단위를 테스트하는 것
        - DAO를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트 가능
    - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요
    - 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려

### 목 프레임워크

단위 테스트 만들기 위해 목 오브젝트의 사용 필수적임

목 오브젝트 만드는 일 번거로울 수 있음 → 프레임 워크 지원

Mockito 프레임워크

- 사용 편리, 코드 직관적
- 인터페이스 이용하여 목 오브젝트 만듬
- 목 오브젝트가 리턴할 값이 있으면 이를 지정해줌 / 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있음
- 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록
- 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증

## 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 됨

핵심 기능은 부가기능을 가진 클래스의 존재 자체를 모름 → 부가기능이 핵심기능을 사용하는 구조

문제 : 클라이언트가 핵심기능을 가진 클래스를 직접 사용해 버리면 부가기능이 적용될 기회가 없음

해결 : 부가기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야함

⇒ 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 함

1. `프록시` 
    - 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
    - 대리자, 대리인과 같은 역할을 함
    - 특징 : 타깃과 같은 인터페이스를 구현함 / 프록시가 타깃을 제어할 수 있는 위치에 있음
    - 사용 목적에 따른 구분
        - 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
        - 타깃에 부가적인 기능을 부여해주기 위해
        
    
    `타깃(=실체)`
    
    - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트

1. `데코레이터 패턴`
    - 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
    - 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않음
    - 프록시가 꼭 한 개로 제한되지 않음
    - 같은 인터페이스를 구현한 타깃과 여러 개의 프록시를 사용할 수 있음

1. 프록시 패턴
    - 디자인 패턴에서 말하는 프록시 패턴 : 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
    - 프록시 패턴의 프록시 : 타깃의 기능 확장, 추가 x / 클라이언트가 타깃 접근하는 방식 바꿔줌
    - 타깃 오브젝트에 대한 레퍼런스가 미리 필요한 경우 : 프록시 패턴 적용 → 타깃 오브젝트 생성 대신 프록시 넘겨줌
    - 구조적으로 프록시와 데코레이터는 유사
        - 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음

### 다이내믹 프록시

문제 : 기존 프록시 번거로움 → 매번 새로운 클래스를 정의해야 하고, 인터페이스의 구현해야 할 메소드는 많으면 모든 메소드를 일일히 구현해서 위임하는 코드를 넣어야 하기 때문

해결 :프록시도 java.lang.reflect 패키지의 API를 통해 손쉽게 만들어낼 수 있음 

1. 리플랙션
    
    다이나믹 프록시 : 리플랙션 기능 이용하여 프록시 생성
    
    리플랙션 : 자바 코드 자체를 추상화 하여 접근하도록 함
    
2. 다이나믹 프록시 적용
    
    프록시로서 필요한 부가기능 제공 코드 직접 작성해야됨
    
    InvocationHandler 인터페이스
    
    - invoke() : 리플렉션의 Method 인터페이스, 메소드를 호출할 때 전달되는 args → 파라미터로 받음
    - 다이내믹 프록시 오브젝트 : 클라이언트의 모든 요청을 리플렉션 정보로 변환 → InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘김
    - 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중 → 중복되는 기능을 효과적으로 제공
    - 다이나믹 프록시로부터 요청 전달받기 → InvocationHandler 구현
    - 다이나믹 프곡시의 생성 → Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메소드를 이용
    
    ### **다이내믹 프록시를 위한 팩토리 빈**
    
    TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어야 할 차례
    
    문제 : DI의 대상이 되는 다이나믹 프록시 오브젝트 → 일반적인 스프링 빈으로 등록할 방법 x
    
    사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 방법이 없음
    
    - 스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의됨
    - 스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성
    
    1. 팩토리 빈
        
        오브젝트 만드는 여러 방안 있음. 그중 팩토리 빈 이용하여 빈 생성 가능
        
        팩토리 빈 :
        
        - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
        - 생성 방법 : 스프링의 FactoryBean이라는 인터페이스를 구현
    
    1. 다이내믹 프록시를 만들어주는 팩토리 빈
        
        문제 : Proxy의 newPRoxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈을 등록할 수 없음
        
        해결 : 팩토리 빈을 사용하여 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줌
        
        - 스프링 빈에는 팩토리 빈과 UserServiceImpl만 빈으로 등록
        - 팩토리 빈 : 다이내믹 프록시가 위임할 타깃 오브젝트인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둠
        - 다이내믹 프록시나 TransactionHandler를 만들 때 필요한 정보 → 팩토리 빈의 프로퍼티로 설정해뒀다가 다이내믹 프록시를 만들면서 전달해줌
    
    ### 프록시 팩토리 빈 방식의 장점과 한계
    
    1. 장점 
        - 다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음
        - 부가기능 코드의 중복 문제 사라짐
            - 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있음
    2. 한계
        - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 것 불가능
        - 하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때 → 여러 개의 부가기능을 수백 개의 클래스에 적용 → 설정 파일은 어마무시하게 복잡해짐
        - 타깃 오브젝트가 변경될 때마다 새로운 오브젝트를 만들어야 함