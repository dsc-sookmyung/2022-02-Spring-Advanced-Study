# 8장 스프링이란 무엇인가?

🔗 [](https://www.notion.so/8-4d29c236bd9c4769bc3e7c658f7a61bf)[https://pickle-fireplant-fa1.notion.site/8-4d29c236bd9c4769bc3e7c658f7a61bf](https://pickle-fireplant-fa1.notion.site/8-4d29c236bd9c4769bc3e7c658f7a61bf)

## **스프링의 정의**

<aside> 💡 자바 엔터프라이즈 개발을 쉽게 할 수 있도록 돕는 오픈소스 경량급 어플리케이션 프레임워크

</aside>

### **애플리케이션 프레임워크**

-   라이브러리 및 프레임워크는 일반적으로 특정 업무 분야나 한 기술에 특화된 목표를 가지고 생성됨
    
-   **그러나**  어플리케이션 프레임워크는 그러지 않고  **애플리케이션 전 영역을 포괄하는 범용적인 프레임워크임**
    
    -   애플리케이션 프레임워크는 단지 여러 계층의 다양한 기술을 한군데 모아둔 것 ❌
    -   스프링의 MVC프레임워크, IoC/DI프레임워크 라고 하면 일부 영역이나 기술에만 주목하는 것임
-   스프링의 일차적인 목적
    
    : 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용하여 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공함으로써 애플리케이션 개발을 편리하게 돕는 애플리케이션 프레임워크로 사용되는 것
    

### **경량급(lightweight)**

-   불필요하게 무겁지 않다는 의미로 EJB같은 과한 엔지니어링이 적용된 기술과 반대되는 개념
-   스프링은 가장 심플한 서버환경(Tomcat, Jetty)에서도 동작. 단순한 개발툴과 기본 개발환경으로도 개발 O
-   코드도 EJB보다 작고 단순 - 프레임워크와 서버환경에 의존적인 부분이 없기 때문

### **자바 엔터프라이즈 개발을 편하게**

-   근본적인 부분에서 엔터프라이즈 개발의 복잡함을 제거하고 개발을 편리하게 하는 근본 해결책 제시
-   편리한 개발 : 개발자가 로우레벨 기술(실수UP) 을 신경쓰지 않고 핵심적인 비즈니스 로직 쉽게 구현하는 것
-   스프링 프레임워크는 개발자들이 프레임워크 기술보다 애플리케이션의 로직에 집중하도록 도움

### **오픈소스**

-   Apache License 2.0 : 상업 목적의 제품 써도 되고, 수정해서 써도 수정한 소스를 공개할 의무 없음
-   오픈소스의 장점: 투명한 방식으로 다양한 참여 가능, 매우 빠르고 유연한 개발이 가능
-   오픈소스의 단점: 지속적이고 안정적인 개발의 불확실성, 개발자 개개인에게 의존적
-   스프링같은 프레임워크가 엔터프라이즈 시스템 개발에 쓰일때, 버그의 방치 및 안정적인 개발이 안돼는건 😧
-   스프링은 오픈소스 개발이라는 방법을 택해서 개발 과정은 공개되어있지만, 공식 개발을 담당하는 기업 존재

## **스프링의 목적**

> **스프링의 목적을 이해하고, 그 목적을 이루는 도구로 잘 활용해야 제대로 된 가치를 얻을 수 있음**
> 
> -   자바의 목적 : 객체지향 프로그래밍을 통해 유연하고 확장성 좋은 어플리케이션을 빠르게 만드는 것
> -   스프링의 목적 : 엔터프라이즈 어플리케이션 개발의 복잡성을 해결해 편리하게 하는 것

### **엔터프라이즈 개발의 복잡함**

1.  기술적인  **제약조건과**  요구사항의 증가
    
    : 여러 사용자의 요청을 동시에 처리하고 기업의 핵심정보나 중요한 시스템을 다루므로 서버 성능, 보안과 안정성, 확장성등 비즈니스 로직 이외의 기술적 고려사항이 늘어났음
    
2.  **비즈니스 로직의 복잡도 증가**
    
    : 기능 요구사항과 정책의 변경 및 수정이 잦으므로 업무의 변화 속도가 빠르고 복잡해졌음
    

⇒ 두가지가 복잡하게 얽혀있음

### **복잡함을 해결하려는 도전**

-   EJB (실패)
    -   핵심 로직에서 일부 기술적 코드를 분리하다가 오히려 EJB 환경과 스펙에 종속적인 코드가 만들어짐
    -   따라서 자바언어가 가진 본래의 장점을 잃어버림
-   Spring (효과적인 해결책)
    -   EJB가 침투적 기술을 사용한 반면, 비침투적인 방식 이용
        -   침투적 기술 : 어떤 기술을 적용했을 때, 그 기술과 관련된 코드나 규약이그 안에 등장 (복잡함 증가)
        -   비침투적 기술 : 기술적용 사실이 코드에 직접 반영X, 기술적용이 코드의 설계, 구현방식에 영향 안줌
    -   비침투적 기술의 사용으로 기술적 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게 분리함

### **복잡함을 상대하는 스프링의 전략**

-   **기술적인 복잡함을 상대하는 전략**

> **문제 1 - 기술에 대한 접근 방식이 일관성이 없고 특정 환경에 종석적임**
> 
> **🔑 해결방법 : 서비스 추상화**
> 
> -   EX) 트랜잭션 추상화, OXM 추상화, 데이터 액세스에 대한 일관된 예외 변환 기능등
> -   로우레벨 기술구현 부분과 기술사용 인터페이스를 분리, 환경과 기술에 독립적인 접근 인터페이스 제공

> **문제 2 - 기술적인 처리를 담당하는 코드가 성격이 다른 코드에도 섞여서 등장함**
> 
> 🔑  **해결방법 : AOP**
> 
> -   EX) 트랜잭션, 보안적용, 로깅, audit등
> -   기술관련 코드를 깔끔히 분리해서 별도의 모듈로 관리

-   **비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략**

> **과거 - 비지니스 로직의 대부분을 DB에 두며, SQL로 비지니스 로직을 표현하고 DB에서 핵심 로직 처리**  공유자원인 DB에 큰 부담이 가며 확장이 힘들고 비용이 많이듦, 개발과 유지보수 및 테스트가 힘듦

> **현재 - 비지니스 로직은 어플리케이션안에서 처리, 스프링은 비침투적인 기술이므로 방해요소 제거를 도움**  확장에 용이하며 테스트도 쉬움

-   **기술과 비즈니스 로직의 복잡함을 해결하는데 공통으로 사용하는 도구: 객체지향과 DI**
    -   객체지향의 설계 기법 적용에 용이한 구조를 만들기 위한 기술을 쉽게 적용하도록 돕는게 기본 전략
    -   서비스 추상화, 템플릿/콜백, AOP 등의 기법들 모두 DI가 근본
    -   DI는 특별한 기술이라기보단 유연하고 확장가능한 객체지향 설계를 하다보면 적용되는 프로그래밍 기법
        -   DI를 의식하다보면 객체 설계시 DI를 적용할 후보가 없을까를 생각해보게 됨
        -   DI는 좋은 오브젝트 설계의 결과물로 DI를 잘 적용하면 객체지향적 장점을 살린 설계가 됨
    -   비침투적인 기술을 만든 이유 : 순수 비즈니스 로직을 담은 코드는 도메인 모델 적용이 쉬워서

<aside> 💡 스프링의 기술과 전략은 객체지향인 자바가 가진 강력한 도구를 극대화해서 사용할 수 있도록 돕는 것

</aside>

## **POJO 프로그래밍**

**기술적으로 스프링이 지향하는 목적**

-   분리됐지만 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 어플 핵심 로직을 담은 코드에 제공
-   Spring application = POJO로 만든 애플리케이션 코드 + POJO의 설계 정보
-   IOC/DI, AOP, PSA은 애플리케이션을 POJO로 개발하도록 하는 기술

### **POJO(**Plain Old Java Object)

-   **POJO의 조건**
    
    1.  특정 규약에 종속되지 않는다.
        -   자바 언어와 꼭 필요한 API외에는 종속X
        -   ↔ EJB나 스트럿츠의 특정 클래스를 상속해서 써야하는 오브젝트
    2.  특정 환경에 종속되지 않는다.
        -   비즈니스 로직을 담은 POJO클래스는 웹 환경 정보나 웹 기술을 담은 클래스/인터페이스를 사용X
            -   직접적으로 웹 환경으로 제한하면 웹 외의 클라이언트가 사용하기 어렵고 테스트에도 어려움
            -   비즈니스 로직을 담은 코드에 HttpServletRequest, HttpSession, 캐시 등을 직접 이용X
        -   ↔ 특정 OS에서 제공하는 기능을 직접호출, WebLogic 서버에서만 쓸 수 있는 API를 직접 쓴 코드
    3.  객체지향적 자바언어의 기본에 충실하다.
        -   ↔ 책임과 역할이 다른 코드를 한 클래스에 몰아넣기, 다른 레이어 코드와 강한 결합
    
    > **진정한 POJO란?**
    
    객체지향적 원리에 충실하며, 환경과 기술에 종속되지 않고 필요에 따라 재활용 가능하게 설계된 오브젝트
    
    POJO 프로그래밍 : POJO에 애플리케이션의 핵심로직과 기능을 담아 설계하고 개발하는 방법
    
-   **POJO의 장점**
    
    POJO가 될 수 있는 조건이 곧 장점 → 깔끔한 코드, 객체지향적 설계의 자유로운 적용이 가능함
    
-   **POJO 프레임워크**
    
    스프링은 기술영역에만 관여하고, 비즈니스로직을 담당하는 POJO에서는 모습을 감춤
    
    데이터 액세스나 웹UI 등 최소한의 방법으로 관여함
    

## **스프링의 기술**

> **스프링이 POJO 프로그래밍을 쉽게 하도록 돕는 기술 - IoC/DI, AOP, PSA**  스프링이 제공하는 기술만 달랑 쓰는게 아니라 스프링이 직접 제공하지 않는 기술에도 해당 기술 적용 가능 위의 기술들은 POJO 기반의 엔터프라이즈 개발을 편리하게 하는 도구일 뿐 아니라 객체지향 원리를 충실히 적용시켜서 나온 결과물이기도 함

![image.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f94b736-4f6b-43cd-bce5-413a2c76b011/image.jpeg)

### 제어의 역전  **IoC/ 의존관계 주입 DI**

> **DI를 사용하는 이유**

오브젝트를 분리후, 인터페이스로 느슨하게 연결후 실제 사용할 대상은 DI로 외부에서 지정하는 이유

→ 유연한 확장을 가능케하려고 (OCP : 개방 폐쇄원칙)

**구체적인 DI의 활용방법**

-   핵심 기능의 변경
    -   실제 의존하는 대상이 가진 핵심 기능을 DI 설정을 통해 변경
    -   EX) 서비스 오브젝트가 사용하는 Dao 구현을 JDBC, JPA, 하이버네이트등으로 변경하기
-   핵심기능의 동적인 변경
    -   애플리케이션 동작 중간에 의존 대상을 다이내믹하게 변경
    -   다이내믹 라우팅 프록시, 프록시 오브젝트 기법을 활용
    -   EX) 사용자별로 모두 독립적인 의존 오브젝트를 두게 하기
        -   한번 로그인한 사용자는 자신만의 오브젝트를 유지하고 서비스 오브젝트가 이를 DI받아서 사용O
-   부가기능의 추가
    -   데코레이터 패턴 적용은 DI를 적용하면 쉬움
    -   부가기능의 추가방식을 특정 오브젝트가 아닌 일반적인 대상으로 적용하면 AOP가 됨
    -   EX) 트랜잭션 기능 부여
-   인터페이스의 변경
    -   오브젝트가 가진 인터페이스가 클라이언트와 호환불가하면, 어댑터 패턴 적용
    -   이를 일반화해서 인터페이스가 다양한 구현을 같은 방식으로 사용하도록, 중간에 인터페이스 어댑터 역할을 하는 레이어를 추가 가능 ( ⇒ 서비스추상화)
-   프록시
    -   lazy loading, 원격 프록시를 적용하려면 프록시가 필요하고 이것도 DI를 통해 이뤄짐
-   템플릿과 콜백
    -   항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 정리해서 템플릿과 콜백으로 생성
    -   콜백은 얼마든지 만들어서 사용 가능 (유연한 확장), 템플릿은 한번 만든뒤 재사용(확장에도 변경X)
-   싱글톤과 오브젝트 스코프
    -   DI할 오브젝트의 생명주기를 제어 가능
        -   DI를 프레임워크로 이용하므로, DI 대상 오브젝트를 컨테이너가 관리하고, 생명주기를 컨테이너가 주관하므로 스코프를 자유롭게 제어할 수 있음
    -   기본 스코프는 싱글톤 컨테이너가 알아서 싱글톤을 만들고 관리하므로 클래스 자체는 싱글톤 고려 없이 자유롭게 설계 가능
    -   request(http요청당 1오브젝트), session(세션당 1오브젝트) 스코프 오브젝트도 DI에 사용O
-   테스트
    -   테스트 대상이 의존하는 오브젝트를 수동으로 목 오브젝트를 주입, 테스트용으로 설정을 별도 생성
    -   이런것들을 적용하기 쉬운 이유가 DI

### 애스펙트 지향 프로그래밍  **AOP**

IoC/DI 기법으로 POJO프로그래밍을 하지만, 일부 서비스는 순수한 객체지향기법만으로 힘듦 ⇒ 해결법 : AOP

-   **AOP의 적용 기법**
    
    1.  스프링처럼 다이내믹 프록시 사용하기
        -   데코레이터 패턴을 응용, 부가기능을 부여할 수 있는 곳은 메서드 호출이 일어나는 지점으로 한정
    2.  자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법
        -   AspectJ 사용 - 메서드 호출 , 특정 호출 경로를 가진 메서드 호출 등등에도 부가기능 제공O
        -   별도의 AOP컴파일러를 이용한 빌드과정을 거치거나, 클래스가 메모리로 로딩될때 바이트코드를 조작해서 이뤄짐. 사용하기 까다롭지만 경우에 따라서는 이걸 써야할 때도 있음
-   **AOP의 적용단계**
    
    어플리케이션에 AOP를 남발하면 다른 개발자가 만든 코드가 예상치않은 방식으로 돌아가는등의 혼란을 초래
    
    1.  미리 준비된 AOP 이용하기
        -   트랜잭션, `@Configurable` (domain오브젝트에 DI를 자동적용해주는 AOP기능)
    2.  전담팀을 통한 정책AOP 적용하기
        -   개개인이 쓰기보단 애플리케이션 전체적으로 이용 가능한 것을 소수의 AOP담당자 관리하에 적용.
        -   보안, 로깅, 데이터 추적, 성능 모니터링 등 정책적으로 적용할만한 기능에 적용하면 유용함 정책이 바뀌어도 모두가 코드를 바꾸지 않아도 되기 때문
    3.  AOP의 자유로운 이용
        -   개발자 자신이 구현하는 기능에 세부적인 AOP적용

### 포터블 서비스 추상화  **PSA(Portable Service Abstraction)**

-   트랜잭션은 AOP와 결합돼서 사용되므로 직접적으로 서비스 추상화를 쓸 필요 없음
-   OXM이나 JavaMail 등을 이용하면 스프링이 정의한 추상 API를 이용해 코드를 작성하고, 구체적 기술과 설정은 xml파일로 지정
-   스프링이 서비스 추상화 대상으로 포함시키지 않더라도 필요하면  **직접 추상 레이어를 도입**하고. 일관성 있는 API를 정의해서 사용할 것. 서비스 추상화에 필요한 기술은 DI
-   테스트가 어렵게 만들어진 API, 설정으로 주요 기능을 외부에서 제어하고 싶을 때도 서비스추상화를 이용O
