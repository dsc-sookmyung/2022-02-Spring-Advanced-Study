# 1장 오브젝트와 의존 관계
## 목차
[1.1 초난감 DAO](#초난감-dao)<br/>
[1.2 DAO의 분리](#dao의-분리)<br/>
[1.3 DAO의 확장](#dao의-확장)<br/>
[1.4 제어의 역전(IoC)](#제어의-역전(ioc))<br/>
[1.5 스프링의 IoC](#스프링의-ioc)<br/>
[1.6 싱글톤 레지스트리와 오브젝트 스코프](#싱글톤-레지스트리와-오브젝트-스코프)<br/>
[1.7 의존관계 주입(DI)](#의존관계-주입(DI))<br/>
[1.8 XML을 이용한 설정](#xml을-이용한-설정)<br/>


## 초난감 DAO
- **DAO** <br/> Data Access Object, DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
- **자바빈** <br/> 원래 비주얼 틀에서 조작 가능한 컴포넌트 <br/> 다음 두 가지 관례를 따라 만들어 진다.
  - 디폴트 생성자 : 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 자바빈은 프로퍼티가 없는 디폴트 생성자를 갖고 있어야 한다.
  - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성. getter, setter를 이용해 수정 또는 조회할 수 있다.
- **테스트**<br/> 교재 코드 p58 -> main으로 테스트를 했다. 하지만 예쁜 코드는 아님. <br/>why? 관심사의 분리가 안되어있음

## DAO의 분리
- **분리와 확장을 고려한 설계를 고려하여 리팩토링** <br/>
  교재 코드 p65 -> 중복 코드의 메소드 추출로 커넥션 만들기를 추출
- **DB 커넥션 만들기의 독립**  <br/> 문제 상황 <br/> UserDao를 구매하고 싶어하는 업체들이 서로 다른 종류의 DB를 사용하고, <br/> DB 커넥션을 가져올 때도 독자적으로 만든 방법을 적용하고 싶어함. <br/> 심지어 나중에 바꿀수도?<br/>
  - 템플릿 메소드 패턴 : <br/> 상속을 통해 슈퍼클래스의 기능 확장. <br/>변하지 않는 기능은 슈퍼클래스에, 변경되는 기능은 서브클래스에서(각 업체들마다 하나씩) p66, 67 <br/> 
   슈퍼클래스에 디폴트로 정의해둔 훅메소드를 서브클래스에서 선택적으로 오버라이드해 사용할 수 있음 <br/>(ex) N사와 B사의 각자 특화된 UserDAO
  - 팩토리 메소드 패턴 : <br/> 상속을 통해 기능을 확장하게 하는 것은 동일함 <br/> 하지만 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
  <<br/> 이 방법을 통해 슈퍼클래스의 기본코드에서 오브젝트 생성 방법을 독립시킴 p68 <br/> (ex) DB커넥션)
- **상속이라는 방법의 한계점** <br/> 
  - 다중 상속 안됨
  - 여전히 상속 관계는 아직 긴밀한 결합을 허용함
  - DB커넥션을 확장했을 때, 이 코드를 DAO마다 하나씩 만들어야 하는가? 

## DAO의 확장
- **클래스의 분리** <br/> DB커넥션을 아예 다른 클래스로 분리한다면? p72 <br/> UserDAO가 DB커넥션을 새로 정의한 클래스(SimpleConnectionMaker)를 상속하게 되므로 아까의 회사 별 DB connection 생성이 안됨, 코드를 변경할 수 없음
- **인터페이스의 도입** <br/> ConnectMaker라는 인터페이스 안에, 적절한 ConnectMaker를 넣어주고, 이를 상속하는 UserDAO P75
<br/>하지만 여전히 ConnectMaker라는 인터페이스 안에 적절한 ConnectMaker를 넣어주는 과정에서 생성자의 코드를 수정해야 하는 경우가 생긴다. (ex) connectionMaker = new DConnectionMaker())
- **관계설정 책임의 분리** <br/>  ConnectionMaker와 DConnectionMaker의 매우 밀접한 관계... 
<br/> 클라이언트(UserDaoTest)에서 관계를 맺어주는 작업을 하면 된다. p82

- **원칙과 패턴 [SOLID 원칙](https://www.nextree.co.kr/p6960/)**
  - SRP(The Single Responsibility Principle)
  - OCP(The Open Closed Principle)
  - LSP(The Liskov Substitution Principle)
  - ISP(The Interface Segregation Principle)
  - DIP(The Dependency Inversion Principle)
- **응집도, 결합도**
  - 높은 응집도 : 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다   
  - 낮은 결합도 : <br/> 결합도 - 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도 <br/> 책임과 관심사가 다른 오브젝트와는 느슨하게 연결된 형태를 유지하는 것. <br/> 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적으로 제공, 나머지는 서로 알 필요도 없도록 하기<br/> 높은 응집도보다 더 민감함
- **전략 패턴**  <br/>
UserDaoTest - UserDao - ConnectMaker의 구조를 디자인 패턴의 시각으로 본다면 전략 패턴

## 제어의 역전(IoC)
- **팩토리** <br/> 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것 != 추상 팩토리 패턴, 팩토리 메소드
<br/> UserDaoTest에서 바로 하지 않고 따로 팩토리 역할의 클래스를 따로 뺀다, <br/> UserDaoTest는 Factory를 생성해서 UserDao를 빼내는 코드 한 줄 P89, 90
- **오브젝트 팩토리의 활용** <br/> 매번 생성해야 한다면, 생성 메서드를 따로 빼서 메서드를 넣어줌 p91
- **제어권의 이전을 통한 제어 관계 역전** <br/> 제어의 역전이란, 제어 흐름 구조가 뒤바뀌는 것 <br/> 모든 제어 권한을 자신이 아닌 다른 대상에게 위임 <br/> (ex)서블릿의 실행은 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출시킨다.)
<br/> 스프링 없이도 IoC를 적용해 봤는데, 이는 스프링만의 기술이 아니며 스프링이 IoC를 기반기술로 삼고 있을 뿐

## 스프링의 IoC
- **어플리케이션 컨텍스트**(= IoC 컨테이너 = 스프링 컨테이너 = 빈 팩토리) <br/> IoC 방식을 따라 만들어진 빈 팩토리. 빈의 생성과 관계설정 같은 제어 담당
- **설정 정보**(= 설정 메타 정보 = configuration) <br/> 어플리케이션 컨텍스트가 IoC를 적용하기 위해 사용하는 메타정보. 설계도 역할. 설정정보를 만드는 방법이 여러가지가 있다. p96
- **어플리케이션 컨텍스트의 동작 방식** <br/> 오브젝트 팩토리 <- 대응관계 -> 스프링의어플리케이션 컨텍스트 p99 그림 1-9
- **어플리케이션 컨텍스트의 장점** 
  - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
  - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
  - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다
- **스프링 프레임워크** <br/> 스프링이 제공하는 모든 기능을 통틀어 말함

## 싱글톤 레지스트리와 오브젝트 스코프
- **싱글톤 패턴** <br/> 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스의 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능함<br/>애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다.
- **싱글톤 레지스트리** <br/> 스프링의 싱글톤 형태의 오브젝트를 만들고 관리하는 기능
- **싱글톤과 오브젝트의 상태** <br/>
  멀티스레드 환경에서 여러 스레드가 싱글톤에 동시에 접근해서 사용할 수 있다. <br/> 따라서 주의해야할 점 <br/> -> 싱글톤은 상태 정보를 내부에 갖고 있지 않는 **무상태 방식**이어야 함
  <br/> -> 각 요청에 대한 정보, DB나 서버 리소스로부터 생성한 정보는 파라미터, 로컬 변수, 리턴 값등을 이용한다.
- **스프링 빈의 스코프** <br/>빈이 생성되고, 존재하고, 적용되는 범위
      - 싱글톤 스코프: 대부분의 빈. 컨테이너가 존재하는 한 계속 유지
      - 프로토타입 스코프: 컨테이너에서 빈을 요청할 때마다 매번 새로운 오브젝트 만들어줌
      - 요청 스코프: 새 HTTP 요청마다 생성
      - 세션 스코프: 웹의 세션의 스코프와 유사

## 의존관계 주읩(DI)
- **의존관계 주입DI** <br/>
스프링이 제공하느 IoC 방식의 핵심<br/>
외부로부터의 주입 <br/>
그 중에서도 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 해야 DI

- **런타임 의존관계 설정** p115
- **의존관계 검색과 주입** P117 daoFactory.connectionMaker(), 118 AnnotationConfigApplicationContext(빈 이름으로 찾기)
- **의존관계 주입 응용**
  - 기능 구현의 교환 <br/>
  문제 상황 <br/>
  개발용 로컬 DB에서 배포를 위해 서버 DB로 변경해야 하는 경우
  DI 사용 x -> 코드를 전면 수정해야 함
  DI 사용   -> ConnectionMaker 구현 클래스 하나 더 만들고 DaoFactory 설정에 넣어주기만 하면 끝
  - 부가기능 추가 - 카운팅
  
- 메소드를 이용한 의존관계 주입
  - setter
  - 일반 메서드
  
## XML을 이용한 설정
  DI 의존관계 설정정보를 XML로 만들 수 있다.
  
